<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tket: tket::PauliTensor&lt; PauliContainer, CoeffType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetket.html">tket</a></li><li class="navelem"><a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classtket_1_1PauliTensor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tket::PauliTensor&lt; PauliContainer, CoeffType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>PauliTensor&lt;PauliContainer, CoeffType&gt;  
 <a href="classtket_1_1PauliTensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a893318a5d4bfb8d918333c00084aaddb" id="r_a893318a5d4bfb8d918333c00084aaddb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a893318a5d4bfb8d918333c00084aaddb">PauliTensor</a> ()</td></tr>
<tr class="memdesc:a893318a5d4bfb8d918333c00084aaddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, giving the empty Pauli string with unit scalar.  <br /></td></tr>
<tr class="separator:a893318a5d4bfb8d918333c00084aaddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afaf6574baac83a07885bd7686b6558" id="r_a6afaf6574baac83a07885bd7686b6558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a6afaf6574baac83a07885bd7686b6558">PauliTensor</a> (const PauliContainer &amp;_string, const CoeffType &amp;_coeff=default_coeff)</td></tr>
<tr class="memdesc:a6afaf6574baac83a07885bd7686b6558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor directly instantiating the Pauli string and coefficient.  <br /></td></tr>
<tr class="separator:a6afaf6574baac83a07885bd7686b6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819a548ccdef279bda49985943cbdca" id="r_a3819a548ccdef279bda49985943cbdca"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a3819a548ccdef279bda49985943cbdca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a3819a548ccdef279bda49985943cbdca">PauliTensor</a> (const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;q, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> p, const CoeffType &amp;_coeff=default_coeff, typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a3819a548ccdef279bda49985943cbdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructor for an individual Pauli in a sparse representation.  <br /></td></tr>
<tr class="separator:a3819a548ccdef279bda49985943cbdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d80e2882b086b26681ddca737385857" id="r_a7d80e2882b086b26681ddca737385857"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a7d80e2882b086b26681ddca737385857"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a7d80e2882b086b26681ddca737385857">PauliTensor</a> (const <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &amp;_string, const CoeffType &amp;_coeff=default_coeff, typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a7d80e2882b086b26681ddca737385857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructor to immediately cast a dense Pauli string on the default register to a sparse representation.  <br /></td></tr>
<tr class="separator:a7d80e2882b086b26681ddca737385857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af920fb3e2e53cbf90bc65b6fdd62136e" id="r_af920fb3e2e53cbf90bc65b6fdd62136e"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:af920fb3e2e53cbf90bc65b6fdd62136e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#af920fb3e2e53cbf90bc65b6fdd62136e">PauliTensor</a> (const std::list&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &amp;qubits, const std::list&lt; <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt; &amp;paulis, const CoeffType &amp;_coeff=default_coeff, typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:af920fb3e2e53cbf90bc65b6fdd62136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for sparse representations which zips together an ordered list of Qubits and Paulis.  <br /></td></tr>
<tr class="separator:af920fb3e2e53cbf90bc65b6fdd62136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b71676f3151c5b18f26d4598c6f370e" id="r_a0b71676f3151c5b18f26d4598c6f370e"><td class="memTemplParams" colspan="2">template&lt;typename CastContainer , typename CastCoeffType &gt; </td></tr>
<tr class="memitem:a0b71676f3151c5b18f26d4598c6f370e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a0b71676f3151c5b18f26d4598c6f370e">operator PauliTensor&lt; CastContainer, CastCoeffType &gt;</a> () const</td></tr>
<tr class="memdesc:a0b71676f3151c5b18f26d4598c6f370e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting operator between different specialisations of <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>.  <br /></td></tr>
<tr class="separator:a0b71676f3151c5b18f26d4598c6f370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fcfec0729f3456c8a8a229d6940979" id="r_a21fcfec0729f3456c8a8a229d6940979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a21fcfec0729f3456c8a8a229d6940979">compare</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:a21fcfec0729f3456c8a8a229d6940979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two PauliTensors of the same type in lexicographical order by the Paulis first, then coefficients.  <br /></td></tr>
<tr class="separator:a21fcfec0729f3456c8a8a229d6940979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912192811d5b77506fa9e793e8087287" id="r_a912192811d5b77506fa9e793e8087287"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a912192811d5b77506fa9e793e8087287">operator==</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other) const</td></tr>
<tr class="separator:a912192811d5b77506fa9e793e8087287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16da850b9347b278fed96f6ed185c5" id="r_aee16da850b9347b278fed96f6ed185c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#aee16da850b9347b278fed96f6ed185c5">operator!=</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other) const</td></tr>
<tr class="separator:aee16da850b9347b278fed96f6ed185c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022042f5cf4a0436d68eccdcaf049f57" id="r_a022042f5cf4a0436d68eccdcaf049f57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a022042f5cf4a0436d68eccdcaf049f57">operator&lt;</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other) const</td></tr>
<tr class="separator:a022042f5cf4a0436d68eccdcaf049f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab391314afa17476cbbb4f9c11259f813" id="r_ab391314afa17476cbbb4f9c11259f813"><td class="memTemplParams" colspan="2">template&lt;typename CT  = CoeffType&gt; </td></tr>
<tr class="memitem:ab391314afa17476cbbb4f9c11259f813"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ab391314afa17476cbbb4f9c11259f813">equiv_mod</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other, unsigned n) const</td></tr>
<tr class="memdesc:ab391314afa17476cbbb4f9c11259f813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equivalence of PauliTensors, explicitly taking the coefficient modulo <code>n</code>.  <br /></td></tr>
<tr class="separator:ab391314afa17476cbbb4f9c11259f813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d811261b94502a5dcb9f9eefa37e21" id="r_a99d811261b94502a5dcb9f9eefa37e21"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a99d811261b94502a5dcb9f9eefa37e21"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a99d811261b94502a5dcb9f9eefa37e21">compress</a> ()</td></tr>
<tr class="memdesc:a99d811261b94502a5dcb9f9eefa37e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a sparse <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by removing identity terms.  <br /></td></tr>
<tr class="separator:a99d811261b94502a5dcb9f9eefa37e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e565acbe4614620483824a700cebd" id="r_a036e565acbe4614620483824a700cebd"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType &gt; </td></tr>
<tr class="memitem:a036e565acbe4614620483824a700cebd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a036e565acbe4614620483824a700cebd">commutes_with</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:a036e565acbe4614620483824a700cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks commutation of two PauliTensors by evaluating how many Qubits have anti-commuting Paulis in the string.  <br /></td></tr>
<tr class="separator:a036e565acbe4614620483824a700cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721883c574e6e388c6ebe386373d5b16" id="r_a721883c574e6e388c6ebe386373d5b16"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a721883c574e6e388c6ebe386373d5b16"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a721883c574e6e388c6ebe386373d5b16">common_qubits</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:a721883c574e6e388c6ebe386373d5b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of Qubits on which this and <code>other</code> have the same non-trivial Pauli (X, Y, Z).  <br /></td></tr>
<tr class="separator:a721883c574e6e388c6ebe386373d5b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad9b577e53dab58f57c7edb0f5332e" id="r_abdad9b577e53dab58f57c7edb0f5332e"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:abdad9b577e53dab58f57c7edb0f5332e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#abdad9b577e53dab58f57c7edb0f5332e">own_qubits</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:abdad9b577e53dab58f57c7edb0f5332e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of Qubits on which this has a non-trivial Pauli (X, Y, Z) but <code>other</code> either doesn't contain or maps to I.  <br /></td></tr>
<tr class="separator:abdad9b577e53dab58f57c7edb0f5332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39d9632b4477a46cb48d027f69a74ac" id="r_af39d9632b4477a46cb48d027f69a74ac"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:af39d9632b4477a46cb48d027f69a74ac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#af39d9632b4477a46cb48d027f69a74ac">conflicting_qubits</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:af39d9632b4477a46cb48d027f69a74ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of Qubits on which this and <code>other</code> have distinct non-trivial Paulis (X, Y, Z).  <br /></td></tr>
<tr class="separator:af39d9632b4477a46cb48d027f69a74ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e1411c5934cbe5959e78c550ef1ab" id="r_afa0e1411c5934cbe5959e78c550ef1ab"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:afa0e1411c5934cbe5959e78c550ef1ab"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#afa0e1411c5934cbe5959e78c550ef1ab">common_indices</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:afa0e1411c5934cbe5959e78c550ef1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of qubits (as unsigned integer indices) on which this and <code>other</code> have the same non-trivial Pauli (X, Y, Z).  <br /></td></tr>
<tr class="separator:afa0e1411c5934cbe5959e78c550ef1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a483e5cd2410864824bfea15ce61ab" id="r_ad3a483e5cd2410864824bfea15ce61ab"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:ad3a483e5cd2410864824bfea15ce61ab"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ad3a483e5cd2410864824bfea15ce61ab">own_indices</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad3a483e5cd2410864824bfea15ce61ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of qubits (as unsigned integer indices) on which this has a non-trivial Pauli (X, Y, Z) but <code>other</code> either doesn't contain (&gt;= size) or maps to I.  <br /></td></tr>
<tr class="separator:ad3a483e5cd2410864824bfea15ce61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b549c78abb6552d2fd9a645297659e" id="r_aa6b549c78abb6552d2fd9a645297659e"><td class="memTemplParams" colspan="2">template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:aa6b549c78abb6552d2fd9a645297659e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#aa6b549c78abb6552d2fd9a645297659e">conflicting_indices</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa6b549c78abb6552d2fd9a645297659e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set of qubits (as unsigned integer indices) on which this and <code>other</code> have distinct non-trivial Paulis (X, Y, Z).  <br /></td></tr>
<tr class="separator:aa6b549c78abb6552d2fd9a645297659e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441d54c4ec951fbdcf23f54769e43786" id="r_a441d54c4ec951fbdcf23f54769e43786"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a441d54c4ec951fbdcf23f54769e43786"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a441d54c4ec951fbdcf23f54769e43786">get</a> (const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;qb) const</td></tr>
<tr class="memdesc:a441d54c4ec951fbdcf23f54769e43786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Pauli at the given index within the string.  <br /></td></tr>
<tr class="separator:a441d54c4ec951fbdcf23f54769e43786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00d9f655db8e64d8f4108724b79872b" id="r_ad00d9f655db8e64d8f4108724b79872b"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:ad00d9f655db8e64d8f4108724b79872b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ad00d9f655db8e64d8f4108724b79872b">get</a> (unsigned qb) const</td></tr>
<tr class="separator:ad00d9f655db8e64d8f4108724b79872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5770704123cc3e0590fc00ff354b60" id="r_afa5770704123cc3e0590fc00ff354b60"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:afa5770704123cc3e0590fc00ff354b60"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#afa5770704123cc3e0590fc00ff354b60">set</a> (const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;qb, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> p)</td></tr>
<tr class="memdesc:afa5770704123cc3e0590fc00ff354b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Pauli at the given index within the string.  <br /></td></tr>
<tr class="separator:afa5770704123cc3e0590fc00ff354b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4dd6e4ef3bc79bf8fc6a565a18545" id="r_a50f4dd6e4ef3bc79bf8fc6a565a18545"><td class="memTemplParams" colspan="2">template&lt;typename PC  = PauliContainer&gt; </td></tr>
<tr class="memitem:a50f4dd6e4ef3bc79bf8fc6a565a18545"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a50f4dd6e4ef3bc79bf8fc6a565a18545">set</a> (unsigned qb, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> p)</td></tr>
<tr class="separator:a50f4dd6e4ef3bc79bf8fc6a565a18545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bfbc93c29757508af57e6212a53d8b" id="r_a10bfbc93c29757508af57e6212a53d8b"><td class="memTemplParams" colspan="2">template&lt;typename CT  = CoeffType&gt; </td></tr>
<tr class="memitem:a10bfbc93c29757508af57e6212a53d8b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a73cbfc417e27d7d298444ed189f06b08">quarter_turns_t</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a10bfbc93c29757508af57e6212a53d8b">is_real_negative</a> () const</td></tr>
<tr class="memdesc:a10bfbc93c29757508af57e6212a53d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts coefficient is real, and returns whether it is negative.  <br /></td></tr>
<tr class="separator:a10bfbc93c29757508af57e6212a53d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2068cf7fbc467f0c3844c5c74afbc47" id="r_ad2068cf7fbc467f0c3844c5c74afbc47"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ad2068cf7fbc467f0c3844c5c74afbc47">to_str</a> () const</td></tr>
<tr class="memdesc:ad2068cf7fbc467f0c3844c5c74afbc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">A human-readable form of the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>, incorporating the coefficient and Pauli string.  <br /></td></tr>
<tr class="separator:ad2068cf7fbc467f0c3844c5c74afbc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f603b9057939b31de6e46c0020ef4" id="r_ae15f603b9057939b31de6e46c0020ef4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ae15f603b9057939b31de6e46c0020ef4">hash_value</a> () const</td></tr>
<tr class="memdesc:ae15f603b9057939b31de6e46c0020ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>.  <br /></td></tr>
<tr class="separator:ae15f603b9057939b31de6e46c0020ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b7cd6475dac95ca1c444fb9a723db" id="r_a034b7cd6475dac95ca1c444fb9a723db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a034b7cd6475dac95ca1c444fb9a723db">transpose</a> ()</td></tr>
<tr class="memdesc:a034b7cd6475dac95ca1c444fb9a723db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this to the transpose by negating the coefficient if the string contains an odd number of Pauli::Ys.  <br /></td></tr>
<tr class="separator:a034b7cd6475dac95ca1c444fb9a723db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7115d52a3e236c071188f8ac1a614a" id="r_aeb7115d52a3e236c071188f8ac1a614a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#aeb7115d52a3e236c071188f8ac1a614a">operator*</a> (const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:aeb7115d52a3e236c071188f8ac1a614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qubit-wise multiplication of two PauliTensors of the same type.  <br /></td></tr>
<tr class="separator:aeb7115d52a3e236c071188f8ac1a614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01fb951955bee002d5d20437d32dd80" id="r_ab01fb951955bee002d5d20437d32dd80"><td class="memTemplParams" colspan="2">template&lt;typename CT  = CoeffType&gt; </td></tr>
<tr class="memitem:ab01fb951955bee002d5d20437d32dd80"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, <a class="el" href="namespacetket.html#ac74e9f3dd71c2a79be4ab7887d943fc2">SymSet</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ab01fb951955bee002d5d20437d32dd80">free_symbols</a> () const</td></tr>
<tr class="memdesc:ab01fb951955bee002d5d20437d32dd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of free symbols in a symbolic <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>.  <br /></td></tr>
<tr class="separator:ab01fb951955bee002d5d20437d32dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87afce6e7a9b254059df7021f4dcdeca" id="r_a87afce6e7a9b254059df7021f4dcdeca"><td class="memTemplParams" colspan="2">template&lt;typename CT  = CoeffType&gt; </td></tr>
<tr class="memitem:a87afce6e7a9b254059df7021f4dcdeca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a87afce6e7a9b254059df7021f4dcdeca">symbol_substitution</a> (const SymEngine::map_basic_basic &amp;sub_map) const</td></tr>
<tr class="memdesc:a87afce6e7a9b254059df7021f4dcdeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces given symbols with values in a symbolic <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>.  <br /></td></tr>
<tr class="separator:a87afce6e7a9b254059df7021f4dcdeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d33127ab0728fbc16de35b48764ac" id="r_a173d33127ab0728fbc16de35b48764ac"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a173d33127ab0728fbc16de35b48764ac">size</a> () const</td></tr>
<tr class="memdesc:a173d33127ab0728fbc16de35b48764ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying Pauli string.  <br /></td></tr>
<tr class="separator:a173d33127ab0728fbc16de35b48764ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60904848d1ed33a71e23a4778944c25" id="r_ab60904848d1ed33a71e23a4778944c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ab60904848d1ed33a71e23a4778944c25">to_sparse_matrix</a> () const</td></tr>
<tr class="memdesc:ab60904848d1ed33a71e23a4778944c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string.  <br /></td></tr>
<tr class="separator:ab60904848d1ed33a71e23a4778944c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab381004d9e2062b5ac5f06424975370e" id="r_ab381004d9e2062b5ac5f06424975370e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ab381004d9e2062b5ac5f06424975370e">to_sparse_matrix</a> (const unsigned n_qubits) const</td></tr>
<tr class="memdesc:ab381004d9e2062b5ac5f06424975370e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string.  <br /></td></tr>
<tr class="separator:ab381004d9e2062b5ac5f06424975370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595226e74b0c6e13fea05589d2fefe45" id="r_a595226e74b0c6e13fea05589d2fefe45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a595226e74b0c6e13fea05589d2fefe45">to_sparse_matrix</a> (const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;qubits) const</td></tr>
<tr class="memdesc:a595226e74b0c6e13fea05589d2fefe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string.  <br /></td></tr>
<tr class="separator:a595226e74b0c6e13fea05589d2fefe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38284c873d20041ca8260bc22ec91ddf" id="r_a38284c873d20041ca8260bc22ec91ddf"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXcd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a38284c873d20041ca8260bc22ec91ddf">dot_state</a> (const Eigen::VectorXcd &amp;state) const</td></tr>
<tr class="memdesc:a38284c873d20041ca8260bc22ec91ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a given statevector by matrix multiplication.  <br /></td></tr>
<tr class="separator:a38284c873d20041ca8260bc22ec91ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698de5a2805c5277dce1f8dda2ce0414" id="r_a698de5a2805c5277dce1f8dda2ce0414"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXcd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a698de5a2805c5277dce1f8dda2ce0414">dot_state</a> (const Eigen::VectorXcd &amp;state, const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;qubits) const</td></tr>
<tr class="memdesc:a698de5a2805c5277dce1f8dda2ce0414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a given statevector by matrix multiplication.  <br /></td></tr>
<tr class="separator:a698de5a2805c5277dce1f8dda2ce0414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c827e51da6fb0e4392579087683d7" id="r_adf6c827e51da6fb0e4392579087683d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetket.html#a68999408b52ab2f0f191f814ec93f4de">Complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#adf6c827e51da6fb0e4392579087683d7">state_expectation</a> (const Eigen::VectorXcd &amp;state) const</td></tr>
<tr class="memdesc:adf6c827e51da6fb0e4392579087683d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the expectation value of a given statevector with respect to the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by matrix multiplication.  <br /></td></tr>
<tr class="separator:adf6c827e51da6fb0e4392579087683d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabc672c625a84d2d931beddae3bafcb" id="r_adabc672c625a84d2d931beddae3bafcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetket.html#a68999408b52ab2f0f191f814ec93f4de">Complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#adabc672c625a84d2d931beddae3bafcb">state_expectation</a> (const Eigen::VectorXcd &amp;state, const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;qubits) const</td></tr>
<tr class="memdesc:adabc672c625a84d2d931beddae3bafcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the expectation value of a given statevector with respect to the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by matrix multiplication.  <br /></td></tr>
<tr class="separator:adabc672c625a84d2d931beddae3bafcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac2e83f786fff6d2beddaf22d2725972d" id="r_ac2e83f786fff6d2beddaf22d2725972d"><td class="memItemLeft" align="right" valign="top">PauliContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#ac2e83f786fff6d2beddaf22d2725972d">string</a></td></tr>
<tr class="separator:ac2e83f786fff6d2beddaf22d2725972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b88652d81a2a1221bc45f7c86f6add2" id="r_a6b88652d81a2a1221bc45f7c86f6add2"><td class="memItemLeft" align="right" valign="top">CoeffType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1PauliTensor.html#a6b88652d81a2a1221bc45f7c86f6add2">coeff</a></td></tr>
<tr class="separator:a6b88652d81a2a1221bc45f7c86f6add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename PauliContainer, typename CoeffType&gt;<br />
class tket::PauliTensor&lt; PauliContainer, CoeffType &gt;</div><p>PauliTensor&lt;PauliContainer, CoeffType&gt; </p>
<p>A unified type for tensor products of Pauli operators, possibly with some global scalar coefficient. It is parameterised in two ways:</p><ul>
<li>PauliContainer describes the data structure used to map qubits to Paulis. This may be sparse or dense, and indexed by arbitrary Qubits or unsigneds (referring to indices in the default register).</li>
<li>CoeffType describes the kind of coefficient stored, ranging from no data to restricted values, to symbolic expressions.</li>
</ul>
<p>Each implementation should be interoperable by casting. Some methods may only be available for certain specialisations. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00522">522</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a893318a5d4bfb8d918333c00084aaddb" name="a893318a5d4bfb8d918333c00084aaddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893318a5d4bfb8d918333c00084aaddb">&#9670;&#160;</a></span>PauliTensor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::PauliTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, giving the empty Pauli string with unit scalar. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00544">544</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a6afaf6574baac83a07885bd7686b6558" name="a6afaf6574baac83a07885bd7686b6558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afaf6574baac83a07885bd7686b6558">&#9670;&#160;</a></span>PauliTensor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::PauliTensor </td>
          <td>(</td>
          <td class="paramtype">const PauliContainer &amp;&#160;</td>
          <td class="paramname"><em>_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffType &amp;&#160;</td>
          <td class="paramname"><em>_coeff</em> = <code>default_coeff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor directly instantiating the Pauli string and coefficient. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00549">549</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a3819a548ccdef279bda49985943cbdca" name="a3819a548ccdef279bda49985943cbdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3819a548ccdef279bda49985943cbdca">&#9670;&#160;</a></span>PauliTensor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::PauliTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffType &amp;&#160;</td>
          <td class="paramname"><em>_coeff</em> = <code>default_coeff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience constructor for an individual Pauli in a sparse representation. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00557">557</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a7d80e2882b086b26681ddca737385857" name="a7d80e2882b086b26681ddca737385857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d80e2882b086b26681ddca737385857">&#9670;&#160;</a></span>PauliTensor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::PauliTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffType &amp;&#160;</td>
          <td class="paramname"><em>_coeff</em> = <code>default_coeff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience constructor to immediately cast a dense Pauli string on the default register to a sparse representation. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00568">568</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="af920fb3e2e53cbf90bc65b6fdd62136e" name="af920fb3e2e53cbf90bc65b6fdd62136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af920fb3e2e53cbf90bc65b6fdd62136e">&#9670;&#160;</a></span>PauliTensor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::PauliTensor </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paulis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffType &amp;&#160;</td>
          <td class="paramname"><em>_coeff</em> = <code>default_coeff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for sparse representations which zips together an ordered list of Qubits and Paulis. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00580">580</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa0e1411c5934cbe5959e78c550ef1ab" name="afa0e1411c5934cbe5959e78c550ef1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0e1411c5934cbe5959e78c550ef1ab">&#9670;&#160;</a></span>common_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::common_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of qubits (as unsigned integer indices) on which this and <code>other</code> have the same non-trivial Pauli (X, Y, Z). </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00725">725</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a721883c574e6e388c6ebe386373d5b16" name="a721883c574e6e388c6ebe386373d5b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721883c574e6e388c6ebe386373d5b16">&#9670;&#160;</a></span>common_qubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::common_qubits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of Qubits on which this and <code>other</code> have the same non-trivial Pauli (X, Y, Z). </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00690">690</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a036e565acbe4614620483824a700cebd" name="a036e565acbe4614620483824a700cebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e565acbe4614620483824a700cebd">&#9670;&#160;</a></span>commutes_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::commutes_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks commutation of two PauliTensors by evaluating how many Qubits have anti-commuting Paulis in the string. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00678">678</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a21fcfec0729f3456c8a8a229d6940979" name="a21fcfec0729f3456c8a8a229d6940979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fcfec0729f3456c8a8a229d6940979">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two PauliTensors of the same type in lexicographical order by the Paulis first, then coefficients. </p>
<p>Ordering rules for each of the Pauli containers or coefficient types may vary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> of the same type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>this &lt; other </td></tr>
    <tr><td class="paramname">0</td><td>this == other </td></tr>
    <tr><td class="paramname">1</td><td>this &gt; other </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00626">626</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a99d811261b94502a5dcb9f9eefa37e21" name="a99d811261b94502a5dcb9f9eefa37e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d811261b94502a5dcb9f9eefa37e21">&#9670;&#160;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compress a sparse <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by removing identity terms. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00663">663</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="aa6b549c78abb6552d2fd9a645297659e" name="aa6b549c78abb6552d2fd9a645297659e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b549c78abb6552d2fd9a645297659e">&#9670;&#160;</a></span>conflicting_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::conflicting_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of qubits (as unsigned integer indices) on which this and <code>other</code> have distinct non-trivial Paulis (X, Y, Z). </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00749">749</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="af39d9632b4477a46cb48d027f69a74ac" name="af39d9632b4477a46cb48d027f69a74ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39d9632b4477a46cb48d027f69a74ac">&#9670;&#160;</a></span>conflicting_qubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::conflicting_qubits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of Qubits on which this and <code>other</code> have distinct non-trivial Paulis (X, Y, Z). </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00713">713</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a38284c873d20041ca8260bc22ec91ddf" name="a38284c873d20041ca8260bc22ec91ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38284c873d20041ca8260bc22ec91ddf">&#9670;&#160;</a></span>dot_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXcd <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::dot_state </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXcd &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a given statevector by matrix multiplication. </p>
<p>Determines the number of qubits from the size of the statevector, and assumes default register qubits in ILO-BE format. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00964">964</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a698de5a2805c5277dce1f8dda2ce0414" name="a698de5a2805c5277dce1f8dda2ce0414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698de5a2805c5277dce1f8dda2ce0414">&#9670;&#160;</a></span>dot_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXcd <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::dot_state </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXcd &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>qubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a given statevector by matrix multiplication. </p>
<p><code>qubits</code> dictates the order of Qubits in the state, assuming a Big Endian format. An exception is thrown if the size of the state does not match up with the number of Qubits given. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00984">984</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ab391314afa17476cbbb4f9c11259f813" name="ab391314afa17476cbbb4f9c11259f813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab391314afa17476cbbb4f9c11259f813">&#9670;&#160;</a></span>equiv_mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename CT  = CoeffType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, bool &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::equiv_mod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for equivalence of PauliTensors, explicitly taking the coefficient modulo <code>n</code>. </p>
<p>This is useful for treatment of Pauli exponentials, where the coefficient becomes the rotation angle under exponentiation and so is unchanged under some modulus. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00651">651</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ab01fb951955bee002d5d20437d32dd80" name="ab01fb951955bee002d5d20437d32dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01fb951955bee002d5d20437d32dd80">&#9670;&#160;</a></span>free_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename CT  = CoeffType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, <a class="el" href="namespacetket.html#ac74e9f3dd71c2a79be4ab7887d943fc2">SymSet</a> &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::free_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of free symbols in a symbolic <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00878">878</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a441d54c4ec951fbdcf23f54769e43786" name="a441d54c4ec951fbdcf23f54769e43786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441d54c4ec951fbdcf23f54769e43786">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;&#160;</td>
          <td class="paramname"><em>qb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Pauli at the given index within the string. </p>
<p>For sparse representations, returns <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66aaa2fe267746e0e15b799ccea11e855878">Pauli::I</a> if index is not present. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00761">761</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ad00d9f655db8e64d8f4108724b79872b" name="ad00d9f655db8e64d8f4108724b79872b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00d9f655db8e64d8f4108724b79872b">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a> &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>qb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00770">770</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ae15f603b9057939b31de6e46c0020ef4" name="ae15f603b9057939b31de6e46c0020ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15f603b9057939b31de6e46c0020ef4">&#9670;&#160;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::hash_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00843">843</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a10bfbc93c29757508af57e6212a53d8b" name="a10bfbc93c29757508af57e6212a53d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bfbc93c29757508af57e6212a53d8b">&#9670;&#160;</a></span>is_real_negative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename CT  = CoeffType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a73cbfc417e27d7d298444ed189f06b08">quarter_turns_t</a> &gt;::value, bool &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::is_real_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asserts coefficient is real, and returns whether it is negative. </p>
<p>quarter_turns_t is used as the coefficient to restrict to the Pauli group. This is most commonly used for stabiliser methods, in which case valid coefficients must be +-1. It is common in such representations for these to be distinguished just by a single phase bit which is true if negative, false if positive. This method immediately gives that phase bit.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if coeff % 4 == 2 (coefficient is -1) </td></tr>
    <tr><td class="paramname">false</td><td>if coeff % 4 == 0 (coefficient is +1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00814">814</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a0b71676f3151c5b18f26d4598c6f370e" name="a0b71676f3151c5b18f26d4598c6f370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b71676f3151c5b18f26d4598c6f370e">&#9670;&#160;</a></span>operator PauliTensor&lt; CastContainer, CastCoeffType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename CastContainer , typename CastCoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::operator <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; CastContainer, CastCoeffType &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casting operator between different specialisations of <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>. </p>
<p>Casts the Pauli container and coefficient separately. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00608">608</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="aee16da850b9347b278fed96f6ed185c5" name="aee16da850b9347b278fed96f6ed185c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee16da850b9347b278fed96f6ed185c5">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00635">635</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="aeb7115d52a3e236c071188f8ac1a614a" name="aeb7115d52a3e236c071188f8ac1a614a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7115d52a3e236c071188f8ac1a614a">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Qubit-wise multiplication of two PauliTensors of the same type. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00863">863</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a022042f5cf4a0436d68eccdcaf049f57" name="a022042f5cf4a0436d68eccdcaf049f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022042f5cf4a0436d68eccdcaf049f57">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00638">638</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a912192811d5b77506fa9e793e8087287" name="a912192811d5b77506fa9e793e8087287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912192811d5b77506fa9e793e8087287">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00632">632</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ad3a483e5cd2410864824bfea15ce61ab" name="ad3a483e5cd2410864824bfea15ce61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a483e5cd2410864824bfea15ce61ab">&#9670;&#160;</a></span>own_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value, std::set&lt; unsigned &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::own_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of qubits (as unsigned integer indices) on which this has a non-trivial Pauli (X, Y, Z) but <code>other</code> either doesn't contain (&gt;= size) or maps to I. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00738">738</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="abdad9b577e53dab58f57c7edb0f5332e" name="abdad9b577e53dab58f57c7edb0f5332e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdad9b577e53dab58f57c7edb0f5332e">&#9670;&#160;</a></span>own_qubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename OtherCoeffType , typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value, std::set&lt; <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::own_qubits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, OtherCoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set of Qubits on which this has a non-trivial Pauli (X, Y, Z) but <code>other</code> either doesn't contain or maps to I. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00702">702</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="afa5770704123cc3e0590fc00ff354b60" name="afa5770704123cc3e0590fc00ff354b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5770704123cc3e0590fc00ff354b60">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a5d170f953029bfd42ce8a82ef89fb814">QubitPauliMap</a> &gt;::value &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtket_1_1Qubit.html">Qubit</a> &amp;&#160;</td>
          <td class="paramname"><em>qb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Pauli at the given index within the string. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00781">781</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a50f4dd6e4ef3bc79bf8fc6a565a18545" name="a50f4dd6e4ef3bc79bf8fc6a565a18545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4dd6e4ef3bc79bf8fc6a565a18545">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename PC  = PauliContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; PC, <a class="el" href="namespacetket.html#a95a55c13860dc28bd46f6b624ccef716">DensePauliMap</a> &gt;::value &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>qb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66a">Pauli</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00794">794</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a173d33127ab0728fbc16de35b48764ac" name="a173d33127ab0728fbc16de35b48764ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d33127ab0728fbc16de35b48764ac">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the underlying Pauli string. </p>
<p>This is taken directly from the container, so may include some qubits mapped to <a class="el" href="namespacetket.html#a342a289d54f4f5f5a405373c07aca66aaa2fe267746e0e15b799ccea11e855878">Pauli::I</a> and vary around calling <a class="el" href="classtket_1_1PauliTensor.html#a99d811261b94502a5dcb9f9eefa37e21" title="Compress a sparse PauliTensor by removing identity terms.">PauliTensor::compress()</a>. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00898">898</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="adf6c827e51da6fb0e4392579087683d7" name="adf6c827e51da6fb0e4392579087683d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6c827e51da6fb0e4392579087683d7">&#9670;&#160;</a></span>state_expectation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetket.html#a68999408b52ab2f0f191f814ec93f4de">Complex</a> <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::state_expectation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXcd &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the expectation value of a given statevector with respect to the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by matrix multiplication. </p>
<p>Determines the number of qubits from the size of the statevector, and assumes default register qubits in ILO-BE format. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l01000">1000</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="adabc672c625a84d2d931beddae3bafcb" name="adabc672c625a84d2d931beddae3bafcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabc672c625a84d2d931beddae3bafcb">&#9670;&#160;</a></span>state_expectation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetket.html#a68999408b52ab2f0f191f814ec93f4de">Complex</a> <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::state_expectation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXcd &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>qubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the expectation value of a given statevector with respect to the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> by matrix multiplication. </p>
<p><code>qubits</code> dictates the order of Qubits in the state, assuming a Big Endian format. An exception is thrown if the size of the state does not match up with the number of Qubits given. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l01011">1011</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a87afce6e7a9b254059df7021f4dcdeca" name="a87afce6e7a9b254059df7021f4dcdeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87afce6e7a9b254059df7021f4dcdeca">&#9670;&#160;</a></span>symbol_substitution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<div class="memtemplate">
template&lt;typename CT  = CoeffType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; CT, <a class="el" href="namespacetket.html#a6817cd1c8a5630b406c86a59173edd21">Expr</a> &gt;::value, <a class="el" href="classtket_1_1PauliTensor.html">PauliTensor</a>&lt; PauliContainer, CoeffType &gt; &gt;::type <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::symbol_substitution </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::map_basic_basic &amp;&#160;</td>
          <td class="paramname"><em>sub_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces given symbols with values in a symbolic <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00888">888</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ab60904848d1ed33a71e23a4778944c25" name="ab60904848d1ed33a71e23a4778944c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60904848d1ed33a71e23a4778944c25">&#9670;&#160;</a></span>to_sparse_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a> <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::to_sparse_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string. </p>
<p>Throws an exception if the coefficient is symbolic.</p>
<p>The matrix gives the operator in ILO-BE format, e.g. (Zq[0], Xq[1]): 0 1 0 0 1 0 0 0 0 0 0 -1 0 0 -1 0</p>
<p>For sparse Pauli containers, just those qubits present in the container will be treated as part of the Pauli string (e.g. (Zq[1], Iq[2]) is treated as ZI since q[0] is ignored but q[2] is present in the string), so it is often preferred to use the other variants which explicitly provide the expected qubits. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00917">917</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a595226e74b0c6e13fea05589d2fefe45" name="a595226e74b0c6e13fea05589d2fefe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595226e74b0c6e13fea05589d2fefe45">&#9670;&#160;</a></span>to_sparse_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a> <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::to_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#ad949814c463d9f998540c0f812e76aa6">qubit_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>qubits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string. </p>
<p>Throws an exception if the coefficient is symbolic.</p>
<p><code>qubits</code> dictates the order of the qubits in the tensor product, with the operator returned in Big Endian format. E.g. (Zq[0], Xq[1]), [q[1], q[0]]: 0 0 1 0 0 0 0 -1 1 0 0 0 0 -1 0 0 </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00953">953</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ab381004d9e2062b5ac5f06424975370e" name="ab381004d9e2062b5ac5f06424975370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab381004d9e2062b5ac5f06424975370e">&#9670;&#160;</a></span>to_sparse_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetket.html#a0b2a87e4bf360a357e15dad177551ed8">CmplxSpMat</a> <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::to_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>n_qubits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a> to a sparse matrix describing the tensor product of each Pauli in the string. </p>
<p>Throws an exception if the coefficient is symbolic.</p>
<p>Qubits are restricted to the default register, from q[0] to q[ <code>n_qubits</code> </p><ul>
<li>1], then presents the operator in ILO-BE format (if a sparse container contains Qubits outside of this range or not in the default register, an exception is thrown). E.g. (Zq[0]), 2: 1 0 0 0 0 -1 0 0 0 0 1 0 0 0 0 -1 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00936">936</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ad2068cf7fbc467f0c3844c5c74afbc47" name="ad2068cf7fbc467f0c3844c5c74afbc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2068cf7fbc467f0c3844c5c74afbc47">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A human-readable form of the <a class="el" href="classtket_1_1PauliTensor.html" title="PauliTensor&lt;PauliContainer, CoeffType&gt;">PauliTensor</a>, incorporating the coefficient and Pauli string. </p>
<p>Format may depend on the type specialisations. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00833">833</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="a034b7cd6475dac95ca1c444fb9a723db" name="a034b7cd6475dac95ca1c444fb9a723db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034b7cd6475dac95ca1c444fb9a723db">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update this to the transpose by negating the coefficient if the string contains an odd number of Pauli::Ys. </p>

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00854">854</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6b88652d81a2a1221bc45f7c86f6add2" name="a6b88652d81a2a1221bc45f7c86f6add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b88652d81a2a1221bc45f7c86f6add2">&#9670;&#160;</a></span>coeff</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoeffType <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::coeff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00539">539</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<a id="ac2e83f786fff6d2beddaf22d2725972d" name="ac2e83f786fff6d2beddaf22d2725972d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e83f786fff6d2beddaf22d2725972d">&#9670;&#160;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PauliContainer , typename CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PauliContainer <a class="el" href="classtket_1_1PauliTensor.html">tket::PauliTensor</a>&lt; PauliContainer, CoeffType &gt;::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PauliTensor_8hpp_source.html#l00538">538</a> of file <a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tket/Utils/<a class="el" href="PauliTensor_8hpp_source.html">PauliTensor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
