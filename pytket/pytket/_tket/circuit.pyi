from typing import Any, ClassVar, Dict, Iterator, List, Optional, Tuple, Union, Set

from typing import overload
import numpy
import numpy.typing as npt

import pytket._tket.architecture
import pytket._tket.pauli
import sympy
from .type_helpers import json, function

_DEBUG_ONE_REG_PREFIX: str
_DEBUG_ZERO_REG_PREFIX: str
_TEMP_BIT_NAME: str
_TEMP_BIT_REG_BASE: str
_TEMP_REG_SIZE: int

class BasisOrder:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    dlo: ClassVar[BasisOrder] = ...
    ilo: ClassVar[BasisOrder] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Bit(UnitID):
    __and__: ClassVar[function] = ...
    __or__: ClassVar[function] = ...
    __rand__: ClassVar[function] = ...
    __ror__: ClassVar[function] = ...
    __rxor__: ClassVar[function] = ...
    __xor__: ClassVar[function] = ...
    @overload
    def __init__(self, index: int) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str, index: int) -> None: ...
    @overload
    def __init__(self, name: str, row: int, col: int) -> None: ...
    @overload
    def __init__(self, name: str, index: List[int]) -> None: ...
    @classmethod
    def from_list(cls, arg0: json) -> Bit: ...
    def to_list(self) -> json: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...

class BitRegister:
    __add__: ClassVar[function] = ...
    __and__: ClassVar[function] = ...
    __floordiv__: ClassVar[function] = ...
    __lshift__: ClassVar[function] = ...
    __mul__: ClassVar[function] = ...
    __or__: ClassVar[function] = ...
    __pow__: ClassVar[function] = ...
    __rand__: ClassVar[function] = ...
    __ror__: ClassVar[function] = ...
    __rshift__: ClassVar[function] = ...
    __rxor__: ClassVar[function] = ...
    __sub__: ClassVar[function] = ...
    __xor__: ClassVar[function] = ...
    name: str
    size: int
    def __init__(self, name: str, size: int) -> None: ...
    def __contains__(self, arg0: Bit) -> bool: ...
    def __copy__(self) -> BitRegister: ...
    def __deepcopy__(self, arg0: dict) -> BitRegister: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: int) -> Bit: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __lt__(self, arg0: BitRegister) -> bool: ...

class CXConfigType:
    __members__: ClassVar[dict] = ...  # read-only
    MultiQGate: ClassVar[CXConfigType] = ...
    Snake: ClassVar[CXConfigType] = ...
    Star: ClassVar[CXConfigType] = ...
    Tree: ClassVar[CXConfigType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CircBox(Op):
    def __init__(self, circ: Circuit) -> None: ...
    def get_circuit(self) -> Circuit: ...

class Circuit:
    add_wasm: ClassVar[function] = ...
    add_wasm_to_reg: ClassVar[function] = ...
    __hash__: ClassVar[None] = ...
    name: Optional[str]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, n_qubits: int, name: Optional[str] = ...) -> None: ...
    @overload
    def __init__(self, n_qubits: int, n_bits: int, name: Optional[str] = ...) -> None: ...
    @overload
    def CCX(self, control_0: int, control_1: int, target: int, **kwargs) -> Circuit: ...
    @overload
    def CCX(self, control_0: Qubit, control_1: Qubit, target: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CH(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CH(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CRx(self, angle: Union[sympy.Expr,float], control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CRx(self, angle: Union[sympy.Expr,float], control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CRy(self, angle: Union[sympy.Expr,float], control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CRy(self, angle: Union[sympy.Expr,float], control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CRz(self, angle: Union[sympy.Expr,float], control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CRz(self, angle: Union[sympy.Expr,float], control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CSWAP(self, control: int, target_0: int, target_1: int, **kwargs) -> Circuit: ...
    @overload
    def CSWAP(self, control: Qubit, target_0: Qubit, target_1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CSX(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CSX(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CSXdg(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CSXdg(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CU1(self, angle: Union[sympy.Expr,float], control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CU1(self, angle: Union[sympy.Expr,float], control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CU3(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CU3(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CV(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CV(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CVdg(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CVdg(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CX(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CX(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CY(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CY(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def CZ(self, control_qubit: int, target_qubit: int, **kwargs) -> Circuit: ...
    @overload
    def CZ(self, control_qubit: Qubit, target_qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ECR(self, qubit_0: int, qubit_1: int, **kwargs) -> Circuit: ...
    @overload
    def ECR(self, qubit_0: Qubit, qubit_1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ESWAP(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def ESWAP(self, angle: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def FSim(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def FSim(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def H(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def H(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ISWAP(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def ISWAP(self, angle: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ISWAPMax(self, qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def ISWAPMax(self, qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Measure(self, qubit: int, bit_index: int, **kwargs) -> Circuit: ...
    @overload
    def Measure(self, qubit: Qubit, bit: Bit, **kwargs) -> Circuit: ...
    def Phase(self, arg0: Union[sympy.Expr,float], **kwargs) -> Circuit: ...
    @overload
    def PhasedISWAP(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def PhasedISWAP(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def PhasedX(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def PhasedX(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Rx(self, angle: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Rx(self, angle: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Ry(self, angle: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Ry(self, angle: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Rz(self, angle: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Rz(self, angle: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def S(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def S(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def SWAP(self, qubit_0: int, qubit_1: int, **kwargs) -> Circuit: ...
    @overload
    def SWAP(self, qubit_0: Qubit, qubit_1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def SX(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def SX(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def SXdg(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def SXdg(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Sdg(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Sdg(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Sycamore(self, qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def Sycamore(self, qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def T(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def T(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def TK1(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def TK1(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def TK2(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def TK2(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Tdg(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Tdg(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def U1(self, angle: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def U1(self, angle: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def U2(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def U2(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def U3(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit: int, **kwargs) -> Circuit: ...
    @overload
    def U3(self, angle0: Union[sympy.Expr,float], angle1: Union[sympy.Expr,float], angle2: Union[sympy.Expr,float], qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def V(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def V(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Vdg(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Vdg(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def X(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def X(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def XXPhase(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def XXPhase(self, qubit0: Union[sympy.Expr,float], qubit1: Qubit, angle: Qubit, **kwargs) -> Circuit: ...
    @overload
    def XXPhase3(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, qubit2: int, **kwargs) -> Circuit: ...
    @overload
    def XXPhase3(self, angle: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, qubit2: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Y(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Y(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def YYPhase(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def YYPhase(self, qubit0: Union[sympy.Expr,float], qubit1: Qubit, angle: Qubit, **kwargs) -> Circuit: ...
    @overload
    def Z(self, qubit: int, **kwargs) -> Circuit: ...
    @overload
    def Z(self, qubit: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ZZMax(self, qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def ZZMax(self, qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def ZZPhase(self, angle: Union[sympy.Expr,float], qubit0: int, qubit1: int, **kwargs) -> Circuit: ...
    @overload
    def ZZPhase(self, angle: Union[sympy.Expr,float], qubit0: Qubit, qubit1: Qubit, **kwargs) -> Circuit: ...
    def _add_w_register(self, size: int) -> None: ...
    @overload
    def _add_wasm(self, funcname: str, wasm_uid: str, width_i_parameter: List[int], width_o_parameter: List[int], args: List[int], wasm_wire_args: List[int], **kwargs) -> Circuit: ...
    @overload
    def _add_wasm(self, funcname: str, wasm_uid: str, width_i_parameter: List[int], width_o_parameter: List[int], args: List[Bit], wasm_wire_args: List[int], **kwargs) -> Circuit: ...
    @overload
    def _add_wasm(self, funcname: str, wasm_uid: str, list_reg_in: List[BitRegister], list_reg_out: List[BitRegister], wasm_wire_args: List[int], **kwargs) -> Circuit: ...
    def _classical_eval(self, arg0: Dict[Bit,bool]) -> Dict[Bit,bool]: ...
    def _n_vertices(self) -> int: ...
    def _to_graphviz_file(self, filename: str) -> None: ...
    @overload
    def add_assertion(self, box: ProjectorAssertionBox, qubits: List[int], ancilla: Optional[int] = ..., name: Optional[str] = ...) -> Circuit: ...
    @overload
    def add_assertion(self, box: ProjectorAssertionBox, qubits: List[Qubit], ancilla: Optional[Qubit] = ..., name: Optional[str] = ...) -> Circuit: ...
    @overload
    def add_assertion(self, box: StabiliserAssertionBox, qubits: List[int], ancilla: int, name: Optional[str] = ...) -> Circuit: ...
    @overload
    def add_assertion(self, box: StabiliserAssertionBox, qubits: List[Qubit], ancilla: Qubit, name: Optional[str] = ...) -> Circuit: ...
    @overload
    def add_barrier(self, qubits: List[int], bits: List[int] = ..., data: str = ...) -> Circuit: ...
    @overload
    def add_barrier(self, units: List[UnitID], data: str = ...) -> Circuit: ...
    def add_bit(self, id: Bit, reject_dups: bool = ...) -> None: ...
    def add_blank_wires(self, number: int) -> None: ...
    @overload
    def add_c_and(self, arg0_in: int, arg1_in: int, arg_out: int, **kwargs) -> Circuit: ...
    @overload
    def add_c_and(self, arg0_in: Bit, arg1_in: Bit, arg_out: Bit, **kwargs) -> Circuit: ...
    def add_c_and_to_registers(self, reg0_in: BitRegister, reg1_in: BitRegister, reg_out: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_c_copybits(self, args_in: List[int], args_out: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_c_copybits(self, args_in: List[Bit], args_out: List[Bit], **kwargs) -> Circuit: ...
    def add_c_copyreg(self, input_reg: BitRegister, output_reg: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_c_modifier(self, values: List[bool], args_in: List[int], arg_inout: int, name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_modifier(self, values: List[bool], args_in: List[Bit], arg_inout: Bit, name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_not(self, arg_in: int, arg_out: int, **kwargs) -> Circuit: ...
    @overload
    def add_c_not(self, arg_in: Bit, arg_out: Bit, **kwargs) -> Circuit: ...
    def add_c_not_to_registers(self, reg_in: BitRegister, reg_out: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_c_or(self, arg0_in: int, arg1_in: int, arg_out: int, **kwargs) -> Circuit: ...
    @overload
    def add_c_or(self, arg0_in: Bit, arg1_in: Bit, arg_out: Bit, **kwargs) -> Circuit: ...
    def add_c_or_to_registers(self, reg0_in: BitRegister, reg1_in: BitRegister, reg_out: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_c_predicate(self, values: List[bool], args_in: List[int], arg_out: int, name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_predicate(self, values: List[bool], args_in: List[Bit], arg_out: Bit, name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_range_predicate(self, minval: int, maxval: int, args_in: List[int], arg_out: int, **kwargs) -> Circuit: ...
    @overload
    def add_c_range_predicate(self, minval: int, maxval: int, args_in: List[Bit], arg_out: Bit, **kwargs) -> Circuit: ...
    @overload
    def add_c_register(self, name: str, size: int) -> BitRegister: ...
    @overload
    def add_c_register(self, register: BitRegister) -> BitRegister: ...
    @overload
    def add_c_setbits(self, values: List[bool], args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_c_setbits(self, values: List[bool], args: List[Bit], **kwargs) -> Circuit: ...
    def add_c_setreg(self, value: int, arg: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_c_transform(self, values: List[int], args: List[int], name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_transform(self, values: List[int], args: List[Bit], name: str = ..., **kwargs) -> Circuit: ...
    @overload
    def add_c_xor(self, arg0_in: int, arg1_in: int, arg_out: int, **kwargs) -> Circuit: ...
    @overload
    def add_c_xor(self, arg0_in: Bit, arg1_in: Bit, arg_out: Bit, **kwargs) -> Circuit: ...
    def add_c_xor_to_registers(self, reg0_in: BitRegister, reg1_in: BitRegister, reg_out: BitRegister, **kwargs) -> Circuit: ...
    @overload
    def add_circbox(self, circbox: CircBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_circbox(self, circbox: CircBox, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_circuit(self, circuit: Circuit, qubits: List[Qubit], bits: List[Bit] = ...) -> Circuit: ...
    @overload
    def add_circuit(self, circuit: Circuit, qubits: List[int], bits: List[int] = ...) -> Circuit: ...
    def add_classicalexpbox_bit(self, expression: object, target: List[Bit], **kwargs) -> Circuit: ...
    def add_classicalexpbox_register(self, expression: object, target: List[Bit], **kwargs) -> Circuit: ...
    @overload
    def add_custom_gate(self, definition: CustomGateDef, params: List[Union[sympy.Expr,float]], qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_custom_gate(self, definition: CustomGateDef, params: List[Union[sympy.Expr,float]], qubits: List[Qubit], **kwargs) -> Circuit: ...
    @overload
    def add_diagonal_box(self, box: DiagonalBox, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_diagonal_box(self, box: DiagonalBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_expbox(self, expbox: ExpBox, qubit_0: int, qubit_1: int, **kwargs) -> Circuit: ...
    @overload
    def add_expbox(self, expbox: ExpBox, qubit_0: Qubit, qubit_1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, Op: Op, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, Op: Op, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, angle: Union[sympy.Expr,float], args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, angle: Union[sympy.Expr,float], args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, angles: List[Union[sympy.Expr,float]], args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_gate(self, type: OpType, angles: List[Union[sympy.Expr,float]], args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexed_tensored_u2(self, box: MultiplexedTensoredU2Box, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexed_tensored_u2(self, box: MultiplexedTensoredU2Box, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexedrotation(self, box: MultiplexedRotationBox, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexedrotation(self, box: MultiplexedRotationBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexedu2(self, box: MultiplexedU2Box, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexedu2(self, box: MultiplexedU2Box, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexor(self, box: MultiplexorBox, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_multiplexor(self, box: MultiplexorBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexpbox(self, pauliexpbox: PauliExpBox, qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexpbox(self, pauliexpbox: PauliExpBox, qubits: List[Qubit], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexpcommutingsetbox(self, pauliexpcommutingsetbox: PauliExpCommutingSetBox, qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexpcommutingsetbox(self, pauliexpcommutingsetbox: PauliExpCommutingSetBox, qubits: List[Qubit], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexppairbox(self, pauliexppairbox: PauliExpPairBox, qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_pauliexppairbox(self, pauliexppairbox: PauliExpPairBox, qubits: List[Qubit], **kwargs) -> Circuit: ...
    def add_phase(self, a: sympy.Expr) -> Circuit: ...
    @overload
    def add_phasepolybox(self, phasepolybox: PhasePolyBox, qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_phasepolybox(self, phasepolybox: PhasePolyBox, qubits: List[Qubit], **kwargs) -> Circuit: ...
    @overload
    def add_q_register(self, name: str, size: int) -> QubitRegister: ...
    @overload
    def add_q_register(self, register: QubitRegister) -> QubitRegister: ...
    @overload
    def add_qcontrolbox(self, qcontrolbox: QControlBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_qcontrolbox(self, qcontrolbox: QControlBox, args: List[UnitID], **kwargs) -> Circuit: ...
    def add_qubit(self, id: Qubit, reject_dups: bool = ...) -> None: ...
    @overload
    def add_state_preparation_box(self, box: StatePreparationBox, args: List[UnitID], **kwargs) -> Circuit: ...
    @overload
    def add_state_preparation_box(self, box: StatePreparationBox, args: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_toffolibox(self, toffolibox: ToffoliBox, qubits: List[int], **kwargs) -> Circuit: ...
    @overload
    def add_toffolibox(self, toffolibox: ToffoliBox, qubits: List[Qubit], **kwargs) -> Circuit: ...
    @overload
    def add_unitary1qbox(self, unitarybox: Unitary1qBox, qubit_0: int, **kwargs) -> Circuit: ...
    @overload
    def add_unitary1qbox(self, unitarybox: Unitary1qBox, qubit_0: Qubit, **kwargs) -> Circuit: ...
    @overload
    def add_unitary2qbox(self, unitarybox: Unitary2qBox, qubit_0: int, qubit_1: int, **kwargs) -> Circuit: ...
    @overload
    def add_unitary2qbox(self, unitarybox: Unitary2qBox, qubit_0: Qubit, qubit_1: Qubit, **kwargs) -> Circuit: ...
    @overload
    def add_unitary3qbox(self, unitarybox: Unitary3qBox, qubit_0: int, qubit_1: int, qubit_2: int, **kwargs) -> Circuit: ...
    @overload
    def add_unitary3qbox(self, unitarybox: Unitary3qBox, qubit_0: Qubit, qubit_1: Qubit, qubit_2: Qubit, **kwargs) -> Circuit: ...
    def append(self, circuit: Circuit) -> None: ...
    def commands_of_type(self, optype: OpType) -> List[Command]: ...
    def copy(self) -> Circuit: ...
    def dagger(self) -> Circuit: ...
    @overload
    def depth(self) -> int: ...
    @overload
    def depth(self) -> Any: ...
    @overload
    def depth(self) -> Any: ...
    @overload
    def depth_by_type(self, type: OpType) -> int: ...
    @overload
    def depth_by_type(self, types: Set[OpType]) -> int: ...
    def flatten_registers(self) -> Dict[UnitID,UnitID]: ...
    def free_symbols(self) -> Set[sympy.Symbol]: ...
    @classmethod
    def from_dict(cls, arg0: json) -> Circuit: ...
    def get_c_register(self, name: str) -> BitRegister: ...
    def get_commands(self) -> List[Command]: ...
    def get_q_register(self, name: str) -> QubitRegister: ...
    def get_statevector(self) -> npt.NDArray[numpy.complex128]: ...
    def get_unitary(self) -> npt.NDArray[numpy.complex128]: ...
    def get_unitary_times_other(self, matr: npt.NDArray[numpy.complex128]) -> npt.NDArray[numpy.complex128]: ...
    def implicit_qubit_permutation(self) -> Dict[Qubit,Qubit]: ...
    def is_symbolic(self) -> bool: ...
    def measure_all(self) -> Circuit: ...
    def measure_register(self, arg0: QubitRegister, arg1: str) -> Circuit: ...
    def n_1qb_gates(self) -> int: ...
    def n_2qb_gates(self) -> int: ...
    def n_gates_of_type(self, type: OpType) -> int: ...
    def n_nqb_gates(self, size: int) -> int: ...
    def ops_of_type(self, optype: OpType) -> List[Op]: ...
    def qubit_create(self, arg0: Qubit) -> None: ...
    def qubit_create_all(self) -> None: ...
    def qubit_discard(self, arg0: Qubit) -> None: ...
    def qubit_discard_all(self) -> None: ...
    def qubit_is_created(self, arg0: Qubit) -> bool: ...
    def qubit_is_discarded(self, arg0: Qubit) -> bool: ...
    def remove_blank_wires(self) -> None: ...
    def rename_units(self, map: Dict[UnitID,UnitID]) -> bool: ...
    def replace_SWAPs(self) -> None: ...
    def replace_implicit_wire_swaps(self) -> None: ...
    @overload
    def substitute_named(self, op: Op, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, repl: Circuit, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: CircBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: Unitary1qBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: Unitary2qBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: Unitary3qBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: ExpBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: PauliExpBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: ToffoliBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: QControlBox, opgroup: str) -> bool: ...
    @overload
    def substitute_named(self, box: CustomGate, opgroup: str) -> bool: ...
    @overload
    def symbol_substitution(self, symbol_map: Dict[sympy.Symbol,sympy.Expr]) -> None: ...
    @overload
    def symbol_substitution(self, symbol_map: Dict[sympy.Symbol,float]) -> None: ...
    def to_dict(self) -> json: ...
    def to_latex_file(self, filename: str) -> None: ...
    def transpose(self) -> Circuit: ...
    def valid_connectivity(self, arch: pytket._tket.architecture.Architecture, directed: bool, allow_bridge: bool = ...) -> bool: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __iter__(self) -> Iterator: ...
    def __mul__(self, arg0: Circuit) -> Circuit: ...
    def __rshift__(self, arg0: Circuit) -> Circuit: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    @property
    def _dag_data(self) -> Tuple[Set[int],Set[int],Set[int],Set[int],Set[int],Set[int],Dict[int,str],Dict[int,str],Dict[int,str],Set[Tuple[int,int,int,int,EdgeType]]]: ...
    @property
    def bit_readout(self) -> Dict[Bit,int]: ...
    @property
    def bits(self) -> List[Bit]: ...
    @property
    def c_registers(self) -> List[BitRegister]: ...
    @property
    def created_qubits(self) -> List[Qubit]: ...
    @property
    def discarded_qubits(self) -> List[Qubit]: ...
    @property
    def is_simple(self) -> bool: ...
    @property
    def n_bits(self) -> int: ...
    @property
    def n_gates(self) -> int: ...
    @property
    def n_qubits(self) -> int: ...
    @property
    def opgroups(self) -> Set[str]: ...
    @property
    def phase(self) -> sympy.Expr: ...
    @property
    def q_registers(self) -> List[QubitRegister]: ...
    @property
    def qubit_readout(self) -> Dict[Qubit,int]: ...
    @property
    def qubit_to_bit_map(self) -> Dict[Qubit,Bit]: ...
    @property
    def qubits(self) -> List[Qubit]: ...

class ClassicalEvalOp(ClassicalOp):
    def __init__(self, *args, **kwargs) -> None: ...

class ClassicalExpBox(Op):
    def __init__(self, n_i: int, n_io: int, n_o: int, exp: object) -> None: ...
    def content_equality(self, arg0: ClassicalExpBox) -> bool: ...
    def get_exp(self) -> object: ...
    def get_n_i(self) -> int: ...
    def get_n_io(self) -> int: ...
    def get_n_o(self) -> int: ...

class ClassicalOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def n_input_outputs(self) -> int: ...
    @property
    def n_inputs(self) -> int: ...
    @property
    def n_outputs(self) -> int: ...

class Command:
    __hash__: ClassVar[None] = ...
    def __init__(self, op: Op, args: List[UnitID]) -> None: ...
    def free_symbols(self) -> Set[sympy.Symbol]: ...
    def __eq__(self, arg0: object) -> bool: ...
    @property
    def args(self) -> List[UnitID]: ...
    @property
    def bits(self) -> List[Bit]: ...
    @property
    def op(self) -> Op: ...
    @property
    def opgroup(self) -> Optional[str]: ...
    @property
    def qubits(self) -> List[Qubit]: ...

class Conditional(Op):
    def __init__(self, op: Op, width: int, value: int) -> None: ...
    @property
    def op(self) -> Op: ...
    @property
    def value(self) -> int: ...
    @property
    def width(self) -> int: ...

class CopyBitsOp(ClassicalEvalOp):
    def __init__(self, *args, **kwargs) -> None: ...

class CustomGate(Op):
    def __init__(self, gatedef: CustomGateDef, params: List[sympy.Expr]) -> None: ...
    def get_circuit(self) -> Circuit: ...
    @property
    def gate(self) -> CustomGateDef: ...
    @property
    def name(self) -> str: ...
    @property
    def params(self) -> List[sympy.Expr]: ...

class CustomGateDef:
    def __init__(self, arg0: str, arg1: Circuit, arg2: List[sympy.Symbol]) -> None: ...
    @classmethod
    def define(cls, name: str, circ: Circuit, args: List[sympy.Symbol]) -> CustomGateDef: ...
    @classmethod
    def from_dict(cls, arg0: json) -> CustomGateDef: ...
    def to_dict(self) -> json: ...
    @property
    def args(self) -> List[sympy.Symbol]: ...
    @property
    def arity(self) -> int: ...
    @property
    def definition(self) -> Circuit: ...
    @property
    def name(self) -> str: ...

class DiagonalBox(Op):
    def __init__(self, diagonal: npt.NDArray[numpy.complex128], upper_triangle: bool = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_diagonal(self) -> npt.NDArray[numpy.complex128]: ...
    def is_upper_triangle(self) -> bool: ...

class EdgeType:
    __members__: ClassVar[dict] = ...  # read-only
    Boolean: ClassVar[EdgeType] = ...
    Classical: ClassVar[EdgeType] = ...
    Quantum: ClassVar[EdgeType] = ...
    WASM: ClassVar[EdgeType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExpBox(Op):
    def __init__(self, A: npt.NDArray[numpy.complex128], t: float, basis: BasisOrder = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...

class MetaOp(Op):
    def __init__(self, type: OpType, signature: List[EdgeType], data: str) -> None: ...
    @property
    def data(self) -> str: ...

class MultiBitOp(ClassicalEvalOp):
    def __init__(self, op: ClassicalEvalOp, multiplier: int) -> None: ...
    @property
    def basic_op(self) -> ClassicalEvalOp: ...

class MultiplexedRotationBox(Op):
    @overload
    def __init__(self, op_map: Dict[List[bool],Op]) -> None: ...
    @overload
    def __init__(self, angles: List[float], axis: OpType) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_op_map(self) -> Dict[tuple,Op]: ...

class MultiplexedTensoredU2Box(Op):
    def __init__(self, op_map: Dict[List[bool],List[Op]]) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_op_map(self) -> Dict[tuple,List[Op]]: ...

class MultiplexedU2Box(Op):
    def __init__(self, op_map: Dict[List[bool],Op], impl_diag: bool = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_impl_diag(self) -> bool: ...
    def get_op_map(self) -> Dict[tuple,Op]: ...

class MultiplexorBox(Op):
    def __init__(self, op_map: Dict[List[bool],Op]) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_op_map(self) -> Dict[tuple,Op]: ...

class Node(Qubit):
    @overload
    def __init__(self, index: int) -> None: ...
    @overload
    def __init__(self, name: str, index: int) -> None: ...
    @overload
    def __init__(self, name: str, row: int, col: int) -> None: ...
    @overload
    def __init__(self, name: str, row: int, col: int, layer: int) -> None: ...
    @overload
    def __init__(self, name: str, index: List[int]) -> None: ...
    @classmethod
    def from_list(cls, arg0: json) -> Node: ...
    def to_list(self) -> json: ...

class Op:
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    @classmethod
    def create(cls, arg0: OpType) -> Op: ...
    @overload
    @classmethod
    def create(cls, arg0: OpType, arg1: sympy.Expr) -> Op: ...
    @overload
    @classmethod
    def create(cls, arg0: OpType, arg1: List[sympy.Expr]) -> Op: ...
    def free_symbols(self) -> Set[sympy.Symbol]: ...
    def get_name(self, latex: bool = ...) -> str: ...
    def get_unitary(self) -> npt.NDArray[numpy.complex128]: ...
    def is_clifford_type(self) -> bool: ...
    def is_gate(self) -> bool: ...
    def __eq__(self, arg0: object) -> bool: ...
    @property
    def dagger(self) -> Op: ...
    @property
    def n_qubits(self) -> int: ...
    @property
    def params(self) -> List[sympy.Expr]: ...
    @property
    def transpose(self) -> Op: ...
    @property
    def type(self) -> OpType: ...

class OpType:
    __members__: ClassVar[dict] = ...  # read-only
    BRIDGE: ClassVar[OpType] = ...
    Barrier: ClassVar[OpType] = ...
    Branch: ClassVar[OpType] = ...
    CCX: ClassVar[OpType] = ...
    CH: ClassVar[OpType] = ...
    CRx: ClassVar[OpType] = ...
    CRy: ClassVar[OpType] = ...
    CRz: ClassVar[OpType] = ...
    CSWAP: ClassVar[OpType] = ...
    CSX: ClassVar[OpType] = ...
    CSXdg: ClassVar[OpType] = ...
    CU1: ClassVar[OpType] = ...
    CU3: ClassVar[OpType] = ...
    CV: ClassVar[OpType] = ...
    CVdg: ClassVar[OpType] = ...
    CX: ClassVar[OpType] = ...
    CY: ClassVar[OpType] = ...
    CZ: ClassVar[OpType] = ...
    CircBox: ClassVar[OpType] = ...
    ClassicalExpBox: ClassVar[OpType] = ...
    ClassicalTransform: ClassVar[OpType] = ...
    CnRy: ClassVar[OpType] = ...
    CnX: ClassVar[OpType] = ...
    CnY: ClassVar[OpType] = ...
    CnZ: ClassVar[OpType] = ...
    Conditional: ClassVar[OpType] = ...
    CopyBits: ClassVar[OpType] = ...
    CustomGate: ClassVar[OpType] = ...
    DiagonalBox: ClassVar[OpType] = ...
    ECR: ClassVar[OpType] = ...
    ESWAP: ClassVar[OpType] = ...
    ExpBox: ClassVar[OpType] = ...
    ExplicitModifier: ClassVar[OpType] = ...
    ExplicitPredicate: ClassVar[OpType] = ...
    FSim: ClassVar[OpType] = ...
    Goto: ClassVar[OpType] = ...
    H: ClassVar[OpType] = ...
    ISWAP: ClassVar[OpType] = ...
    ISWAPMax: ClassVar[OpType] = ...
    Label: ClassVar[OpType] = ...
    Measure: ClassVar[OpType] = ...
    MultiBit: ClassVar[OpType] = ...
    MultiplexedRotationBox: ClassVar[OpType] = ...
    MultiplexedTensoredU2Box: ClassVar[OpType] = ...
    MultiplexedU2Box: ClassVar[OpType] = ...
    MultiplexorBox: ClassVar[OpType] = ...
    NPhasedX: ClassVar[OpType] = ...
    PauliExpBox: ClassVar[OpType] = ...
    PauliExpCommutingSetBox: ClassVar[OpType] = ...
    PauliExpPairBox: ClassVar[OpType] = ...
    Phase: ClassVar[OpType] = ...
    PhasePolyBox: ClassVar[OpType] = ...
    PhasedISWAP: ClassVar[OpType] = ...
    PhasedX: ClassVar[OpType] = ...
    QControlBox: ClassVar[OpType] = ...
    RangePredicate: ClassVar[OpType] = ...
    Reset: ClassVar[OpType] = ...
    Rx: ClassVar[OpType] = ...
    Ry: ClassVar[OpType] = ...
    Rz: ClassVar[OpType] = ...
    S: ClassVar[OpType] = ...
    SWAP: ClassVar[OpType] = ...
    SX: ClassVar[OpType] = ...
    SXdg: ClassVar[OpType] = ...
    Sdg: ClassVar[OpType] = ...
    SetBits: ClassVar[OpType] = ...
    StatePreparationBox: ClassVar[OpType] = ...
    Stop: ClassVar[OpType] = ...
    Sycamore: ClassVar[OpType] = ...
    T: ClassVar[OpType] = ...
    TK1: ClassVar[OpType] = ...
    TK2: ClassVar[OpType] = ...
    Tdg: ClassVar[OpType] = ...
    ToffoliBox: ClassVar[OpType] = ...
    U1: ClassVar[OpType] = ...
    U2: ClassVar[OpType] = ...
    U3: ClassVar[OpType] = ...
    Unitary1qBox: ClassVar[OpType] = ...
    Unitary2qBox: ClassVar[OpType] = ...
    Unitary3qBox: ClassVar[OpType] = ...
    V: ClassVar[OpType] = ...
    Vdg: ClassVar[OpType] = ...
    WASM: ClassVar[OpType] = ...
    X: ClassVar[OpType] = ...
    XXPhase: ClassVar[OpType] = ...
    XXPhase3: ClassVar[OpType] = ...
    Y: ClassVar[OpType] = ...
    YYPhase: ClassVar[OpType] = ...
    Z: ClassVar[OpType] = ...
    ZZMax: ClassVar[OpType] = ...
    ZZPhase: ClassVar[OpType] = ...
    __entries: ClassVar[dict] = ...
    noop: ClassVar[OpType] = ...
    def __init__(self, value: int) -> None: ...
    @classmethod
    def from_name(cls, arg0: json) -> OpType: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PauliExpBox(Op):
    def __init__(self, paulis: List[pytket._tket.pauli.Pauli], t: sympy.Expr, cx_config_type: CXConfigType = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_cx_config(self) -> CXConfigType: ...
    def get_paulis(self) -> List[pytket._tket.pauli.Pauli]: ...
    def get_phase(self) -> sympy.Expr: ...

class PauliExpCommutingSetBox(Op):
    def __init__(self, pauli_gadgets: List[Tuple[List[pytket._tket.pauli.Pauli],sympy.Expr]], cx_config_type: CXConfigType = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_cx_config(self) -> CXConfigType: ...
    def get_paulis(self) -> List[Tuple[List[pytket._tket.pauli.Pauli],sympy.Expr]]: ...

class PauliExpPairBox(Op):
    def __init__(self, paulis0: List[pytket._tket.pauli.Pauli], t0: sympy.Expr, paulis1: List[pytket._tket.pauli.Pauli], t1: sympy.Expr, cx_config_type: CXConfigType = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_cx_config(self) -> CXConfigType: ...
    def get_paulis_pair(self) -> Tuple[List[pytket._tket.pauli.Pauli],List[pytket._tket.pauli.Pauli]]: ...
    def get_phase_pair(self) -> Tuple[sympy.Expr,sympy.Expr]: ...

class PhasePolyBox(Op):
    @overload
    def __init__(self, n_qubits: int, qubit_indices: Dict[Qubit,int], phase_polynomial: Dict[List[bool],sympy.Expr], linear_transformation: npt.NDArray[numpy.bool_]) -> None: ...
    @overload
    def __init__(self, circuit: Circuit) -> None: ...
    def get_circuit(self) -> Circuit: ...
    @property
    def linear_transformation(self) -> npt.NDArray[numpy.bool_]: ...
    @property
    def n_qubits(self) -> int: ...
    @property
    def phase_polynomial(self) -> Dict[tuple,sympy.Expr]: ...
    @property
    def qubit_indices(self) -> Dict[Qubit,int]: ...

class ProjectorAssertionBox(Op):
    def __init__(self, m: npt.NDArray[numpy.complex128], basis: BasisOrder = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_matrix(self) -> npt.NDArray[numpy.complex128]: ...

class QControlBox(Op):
    def __init__(self, op: Op, n: int = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_n_controls(self) -> int: ...
    def get_op(self) -> Op: ...

class Qubit(UnitID):
    @overload
    def __init__(self, index: int) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str, index: int) -> None: ...
    @overload
    def __init__(self, name: str, row: int, col: int) -> None: ...
    @overload
    def __init__(self, name: str, index: List[int]) -> None: ...
    @classmethod
    def from_list(cls, arg0: json) -> Qubit: ...
    def to_list(self) -> json: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class QubitRegister:
    name: str
    size: int
    def __init__(self, name: str, size: int) -> None: ...
    def __contains__(self, arg0: Qubit) -> bool: ...
    def __copy__(self) -> QubitRegister: ...
    def __deepcopy__(self, arg0: dict) -> QubitRegister: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: int) -> Qubit: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __lt__(self, arg0: QubitRegister) -> bool: ...

class RangePredicateOp(ClassicalEvalOp):
    def __init__(self, width: int, upper: int, lower: int) -> None: ...
    @property
    def lower(self) -> int: ...
    @property
    def upper(self) -> int: ...

class SetBitsOp(ClassicalEvalOp):
    def __init__(self, values: List[bool]) -> None: ...
    @property
    def values(self) -> List[bool]: ...

class StabiliserAssertionBox(Op):
    @overload
    def __init__(self, stabilisers: List[pytket._tket.pauli.PauliStabiliser]) -> None: ...
    @overload
    def __init__(self, stabilisers: List[str]) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_stabilisers(self) -> List[pytket._tket.pauli.PauliStabiliser]: ...

class StatePreparationBox(Op):
    def __init__(self, statevector: npt.NDArray[numpy.complex128], is_inverse: bool = ..., with_initial_reset: bool = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_statevector(self) -> npt.NDArray[numpy.complex128]: ...
    def is_inverse(self) -> bool: ...
    def with_initial_reset(self) -> bool: ...

class ToffoliBox(Op):
    @overload
    def __init__(self, permutation: Dict[List[bool],List[bool]], strat: ToffoliBoxSynthStrat, rotation_axis: OpType = ...) -> None: ...
    @overload
    def __init__(self, permutation: Dict[List[bool],List[bool]], rotation_axis: OpType = ...) -> None: ...
    @overload
    def __init__(self, n_qubits: int, permutation: Dict[List[bool],List[bool]], rotation_axis: OpType = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_permutation(self) -> Dict[tuple,tuple]: ...
    def get_rotation_axis(self) -> OpType: ...
    def get_strat(self) -> ToffoliBoxSynthStrat: ...

class ToffoliBoxSynthStrat:
    __members__: ClassVar[dict] = ...  # read-only
    Cycle: ClassVar[ToffoliBoxSynthStrat] = ...
    Matching: ClassVar[ToffoliBoxSynthStrat] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnitID:
    def __init__(self) -> None: ...
    def __copy__(self) -> UnitID: ...
    def __deepcopy__(self, arg0: dict) -> UnitID: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: UnitID) -> bool: ...
    @property
    def index(self) -> List[int]: ...
    @property
    def reg_name(self) -> str: ...
    @property
    def type(self) -> UnitType: ...

class UnitType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    bit: ClassVar[UnitType] = ...
    qubit: ClassVar[UnitType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Unitary1qBox(Op):
    def __init__(self, m: npt.NDArray[numpy.complex128]) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_matrix(self) -> npt.NDArray[numpy.complex128]: ...

class Unitary2qBox(Op):
    def __init__(self, m: npt.NDArray[numpy.complex128], basis: BasisOrder = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_matrix(self) -> npt.NDArray[numpy.complex128]: ...

class Unitary3qBox(Op):
    def __init__(self, m: npt.NDArray[numpy.complex128], basis: BasisOrder = ...) -> None: ...
    def get_circuit(self) -> Circuit: ...
    def get_matrix(self) -> npt.NDArray[numpy.complex128]: ...

class WASMOp(ClassicalOp):
    def __init__(self, num_bits: int, num_w: int, n_inputs: List[int], n_outputs: List[int], func_name: str, wasm_uid: str) -> None: ...
    @property
    def func_name(self) -> str: ...
    @property
    def input_widths(self) -> List[int]: ...
    @property
    def n_i32(self) -> int: ...
    @property
    def num_bits(self) -> int: ...
    @property
    def num_w(self) -> int: ...
    @property
    def output_widths(self) -> List[int]: ...
    @property
    def wasm_uid(self) -> str: ...

def fresh_symbol(preferred: str = ...) -> sympy.Symbol: ...
