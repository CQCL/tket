from typing import Any
from typing import Callable, ClassVar, Dict, List, Optional, Union

from typing import overload
import pytket._tket.architecture
import pytket._tket.circuit
import pytket._tket.mapping
import pytket._tket.placement
import pytket._tket.predicates
import pytket._tket.transform
import pytket._tket.unit_id
import sympy
Audit: SafetyMode
Default: SafetyMode
HamPath: CNotSynthType
Rec: CNotSynthType
SWAP: CNotSynthType

class BasePass:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    def apply(self, compilation_unit: pytket._tket.predicates.CompilationUnit, safety_mode: SafetyMode = ...) -> bool: ...
    @overload
    def apply(self, circuit: pytket._tket.circuit.Circuit) -> bool: ...
    @overload
    def apply(self, circuit: pytket._tket.circuit.Circuit, before_apply: Callable[[pytket._tket.predicates.CompilationUnit,object],None], after_apply: Callable[[pytket._tket.predicates.CompilationUnit,object],None]) -> bool: ...
    @classmethod
    def from_dict(cls, arg0: dict) -> BasePass: ...
    def to_dict(self) -> dict: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class CNotSynthType:
    __members__: ClassVar[dict] = ...  # read-only
    HamPath: ClassVar[CNotSynthType] = ...
    Rec: ClassVar[CNotSynthType] = ...
    SWAP: ClassVar[CNotSynthType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RepeatPass(BasePass):
    def __init__(self, compilation_pass: BasePass) -> None: ...
    def get_pass(self) -> BasePass: ...

class RepeatUntilSatisfiedPass(BasePass):
    @overload
    def __init__(self, compilation_pass: BasePass, predicate: pytket._tket.predicates.Predicate) -> None: ...
    @overload
    def __init__(self, compilation_pass: BasePass, check_function: Callable[[pytket._tket.circuit.Circuit],bool]) -> None: ...
    def get_pass(self) -> BasePass: ...
    def get_predicate(self) -> pytket._tket.predicates.Predicate: ...

class RepeatWithMetricPass(BasePass):
    def __init__(self, compilation_pass: BasePass, metric: Callable[[pytket._tket.circuit.Circuit],int]) -> None: ...
    def get_metric(self) -> Callable[[pytket._tket.circuit.Circuit],int]: ...
    def get_pass(self) -> BasePass: ...

class SafetyMode:
    __members__: ClassVar[dict] = ...  # read-only
    Audit: ClassVar[SafetyMode] = ...
    Default: ClassVar[SafetyMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SequencePass(BasePass):
    def __init__(self, pass_list: List[BasePass]) -> None: ...
    def get_sequence(self) -> List[BasePass]: ...

def AASRouting(arc: pytket._tket.architecture.Architecture, **kwargs: Any) -> BasePass: ...
def CXMappingPass(arc: pytket._tket.architecture.Architecture, placer: pytket._tket.placement.Placement, **kwargs: Any) -> BasePass: ...
def CliffordSimp(allow_swaps: bool = ...) -> BasePass: ...
def CnXPairwiseDecomposition() -> BasePass: ...
def CommuteThroughMultis() -> BasePass: ...
def ComposePhasePolyBoxes(min_size: int = ...) -> BasePass: ...
def ContextSimp(allow_classical: bool = ..., xcirc: Optional[pytket._tket.circuit.Circuit] = ...) -> BasePass: ...
def CustomPass(transform: Callable[[pytket._tket.circuit.Circuit],pytket._tket.circuit.Circuit], label: str = ...) -> BasePass: ...
def CustomRoutingPass(arc: pytket._tket.architecture.Architecture, config: List[pytket._tket.mapping.RoutingMethod]) -> BasePass: ...
def DecomposeArbitrarilyControlledGates() -> BasePass: ...
def DecomposeBoxes() -> BasePass: ...
def DecomposeClassicalExp() -> BasePass: ...
def DecomposeMultiQubitsCX() -> BasePass: ...
def DecomposeSingleQubitsTK1() -> BasePass: ...
def DecomposeSwapsToCXs(arc: pytket._tket.architecture.Architecture, respect_direction: bool = ...) -> BasePass: ...
def DecomposeSwapsToCircuit(replacement_circuit: pytket._tket.circuit.Circuit) -> BasePass: ...
def DecomposeTK2(allow_swaps: bool = ..., **kwargs: Any) -> BasePass: ...
def DefaultMappingPass(arc: pytket._tket.architecture.Architecture, delay_measures: bool = ...) -> BasePass: ...
def DelayMeasures(allow_partial: bool = ...) -> BasePass: ...
def EulerAngleReduction(q: pytket._tket.circuit.OpType, p: pytket._tket.circuit.OpType, strict: bool = ...) -> BasePass: ...
def FlattenRegisters() -> BasePass: ...
def FlattenRelabelRegistersPass(label: str = ...) -> BasePass: ...
def FullMappingPass(arc: pytket._tket.architecture.Architecture, placer: pytket._tket.placement.Placement, config: List[pytket._tket.mapping.RoutingMethod]) -> BasePass: ...
def FullPeepholeOptimise(allow_swaps: bool = ..., target_2qb_gate: pytket._tket.circuit.OpType = ...) -> BasePass: ...
def GlobalisePhasedX(squash: bool = ...) -> BasePass: ...
def GuidedPauliSimp(strat: pytket._tket.transform.PauliSynthStrat = ..., cx_config: pytket._tket.circuit.CXConfigType = ...) -> BasePass: ...
@overload
def KAKDecomposition(target_2qb_gate: pytket._tket.circuit.OpType = ..., cx_fidelity: float = ..., allow_swaps: bool = ...) -> BasePass: ...
@overload
def KAKDecomposition(cx_fidelity: float) -> BasePass: ...
def NaivePlacementPass(arc: pytket._tket.architecture.Architecture) -> BasePass: ...
def NormaliseTK2() -> BasePass: ...
def OptimisePhaseGadgets(cx_config: pytket._tket.circuit.CXConfigType = ...) -> BasePass: ...
def PauliExponentials(strat: pytket._tket.transform.PauliSynthStrat = ..., cx_config: pytket._tket.circuit.CXConfigType = ...) -> BasePass: ...
def PauliSimp(strat: pytket._tket.transform.PauliSynthStrat = ..., cx_config: pytket._tket.circuit.CXConfigType = ...) -> BasePass: ...
def PauliSquash(strat: pytket._tket.transform.PauliSynthStrat = ..., cx_config: pytket._tket.circuit.CXConfigType = ...) -> BasePass: ...
def PeepholeOptimise2Q(allow_swaps: bool = ...) -> BasePass: ...
def PlacementPass(placer: pytket._tket.placement.Placement) -> BasePass: ...
@overload
def RebaseCustom(gateset: set[pytket._tket.circuit.OpType], cx_replacement: pytket._tket.circuit.Circuit, tk1_replacement: Callable[[Union[sympy.Expr,float],Union[sympy.Expr,float],Union[sympy.Expr,float]],pytket._tket.circuit.Circuit]) -> BasePass: ...
@overload
def RebaseCustom(gateset: set[pytket._tket.circuit.OpType], tk2_replacement: Callable[[Union[sympy.Expr,float],Union[sympy.Expr,float],Union[sympy.Expr,float]],pytket._tket.circuit.Circuit], tk1_replacement: Callable[[Union[sympy.Expr,float],Union[sympy.Expr,float],Union[sympy.Expr,float]],pytket._tket.circuit.Circuit]) -> BasePass: ...
def RebaseTket() -> BasePass: ...
def RemoveBarriers() -> BasePass: ...
def RemoveDiscarded() -> BasePass: ...
def RemoveImplicitQubitPermutation() -> BasePass: ...
def RemoveRedundancies() -> BasePass: ...
def RenameQubitsPass(qubit_map: Dict[pytket._tket.unit_id.Qubit,pytket._tket.unit_id.Qubit]) -> BasePass: ...
def RoundAngles(n: int, only_zeros: bool = ...) -> BasePass: ...
def RoutingPass(arc: pytket._tket.architecture.Architecture) -> BasePass: ...
def SimplifyInitial(allow_classical: bool = ..., create_all_qubits: bool = ..., remove_redundancies: bool = ..., xcirc: pytket._tket.circuit.Circuit = ...) -> BasePass: ...
def SimplifyMeasured() -> BasePass: ...
def SquashCustom(singleqs: set[pytket._tket.circuit.OpType], tk1_replacement: Callable[[Union[sympy.Expr,float],Union[sympy.Expr,float],Union[sympy.Expr,float]],pytket._tket.circuit.Circuit], always_squash_symbols: bool = ...) -> BasePass: ...
def SquashRzPhasedX() -> BasePass: ...
def SquashTK1() -> BasePass: ...
def SynthesiseHQS() -> BasePass: ...
def SynthesiseOQC() -> BasePass: ...
def SynthesiseTK() -> BasePass: ...
def SynthesiseTket() -> BasePass: ...
def SynthesiseUMD() -> BasePass: ...
def ThreeQubitSquash(allow_swaps: bool = ...) -> BasePass: ...
def ZXGraphlikeOptimisation() -> BasePass: ...
def ZZPhaseToRz() -> BasePass: ...
