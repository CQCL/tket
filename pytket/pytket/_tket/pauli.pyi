from numpy.typing import NDArray
from typing import ClassVar, Dict, List, Tuple

from typing import overload
import numpy
import pytket._tket.unit_id
import scipy.sparse
I: Pauli
X: Pauli
Y: Pauli
Z: Pauli

class Pauli:
    __members__: ClassVar[dict] = ...  # read-only
    I: ClassVar[Pauli] = ...
    X: ClassVar[Pauli] = ...
    Y: ClassVar[Pauli] = ...
    Z: ClassVar[Pauli] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PauliStabiliser:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, string: List[Pauli], coeff: int) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    @property
    def coeff(self) -> int: ...
    @property
    def string(self) -> List[Pauli]: ...

class QubitPauliString:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, qubit: pytket._tket.unit_id.Qubit, pauli: Pauli) -> None: ...
    @overload
    def __init__(self, qubits: List[pytket._tket.unit_id.Qubit], paulis: List[Pauli]) -> None: ...
    @overload
    def __init__(self, map: Dict[pytket._tket.unit_id.Qubit,Pauli]) -> None: ...
    def commutes_with(self, other: QubitPauliString) -> bool: ...
    def compress(self) -> None: ...
    @overload
    def dot_state(self, state: NDArray[numpy.complex128]) -> NDArray[numpy.complex128]: ...
    @overload
    def dot_state(self, state: NDArray[numpy.complex128], qubits: List[pytket._tket.unit_id.Qubit]) -> NDArray[numpy.complex128]: ...
    @classmethod
    def from_list(cls, arg0: list) -> QubitPauliString: ...
    @overload
    def state_expectation(self, state: NDArray[numpy.complex128]) -> complex: ...
    @overload
    def state_expectation(self, state: NDArray[numpy.complex128], qubits: List[pytket._tket.unit_id.Qubit]) -> complex: ...
    def to_list(self) -> list: ...
    @overload
    def to_sparse_matrix(self) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, n_qubits: int) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, qubits: List[pytket._tket.unit_id.Qubit]) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: pytket._tket.unit_id.Qubit) -> Pauli: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: QubitPauliString) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __setitem__(self, arg0: pytket._tket.unit_id.Qubit, arg1: Pauli) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    @property
    def map(self) -> Dict[pytket._tket.unit_id.Qubit,Pauli]: ...

class QubitPauliTensor:
    coeff: complex
    string: QubitPauliString
    @overload
    def __init__(self, coeff: complex = ...) -> None: ...
    @overload
    def __init__(self, qubit: pytket._tket.unit_id.Qubit, pauli: Pauli, coeff: complex = ...) -> None: ...
    @overload
    def __init__(self, qubits: List[pytket._tket.unit_id.Qubit], paulis: List[Pauli], coeff: complex = ...) -> None: ...
    @overload
    def __init__(self, map: Dict[pytket._tket.unit_id.Qubit,Pauli], coeff: complex = ...) -> None: ...
    @overload
    def __init__(self, string: QubitPauliString, coeff: complex = ...) -> None: ...
    def commutes_with(self, other: QubitPauliTensor) -> bool: ...
    def compress(self) -> None: ...
    @overload
    def dot_state(self, state: NDArray[numpy.complex128]) -> NDArray[numpy.complex128]: ...
    @overload
    def dot_state(self, state: NDArray[numpy.complex128], qubits: List[pytket._tket.unit_id.Qubit]) -> NDArray[numpy.complex128]: ...
    @overload
    def state_expectation(self, state: NDArray[numpy.complex128]) -> complex: ...
    @overload
    def state_expectation(self, state: NDArray[numpy.complex128], qubits: List[pytket._tket.unit_id.Qubit]) -> complex: ...
    @overload
    def to_sparse_matrix(self) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, n_qubits: int) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, qubits: List[pytket._tket.unit_id.Qubit]) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: pytket._tket.unit_id.Qubit) -> Pauli: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: QubitPauliTensor) -> bool: ...
    def __mul__(self, arg0: QubitPauliTensor) -> QubitPauliTensor: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __rmul__(self, arg0: complex) -> QubitPauliTensor: ...
    def __setitem__(self, arg0: pytket._tket.unit_id.Qubit, arg1: Pauli) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...

def pauli_string_mult(qubitpaulistring1: QubitPauliString, qubitpaulistring2: QubitPauliString) -> Tuple[QubitPauliString,complex]: ...
