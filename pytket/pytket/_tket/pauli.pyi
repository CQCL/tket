from typing import ClassVar, Dict, List, Tuple

from typing import overload
import numpy
import numpy.typing as npt
import pytket._tket.circuit
import scipy.sparse # type: ignore
from .type_helpers import json
I: Pauli
X: Pauli
Y: Pauli
Z: Pauli

class Pauli:
    __members__: ClassVar[dict] = ...  # read-only
    I: ClassVar[Pauli] = ...
    X: ClassVar[Pauli] = ...
    Y: ClassVar[Pauli] = ...
    Z: ClassVar[Pauli] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PauliStabiliser:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, string: List[Pauli], coeff: int) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...
    @property
    def coeff(self) -> int: ...
    @property
    def string(self) -> List[Pauli]: ...

class QubitPauliString:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, qubit: pytket._tket.circuit.Qubit, pauli: Pauli) -> None: ...
    @overload
    def __init__(self, qubits: List[pytket._tket.circuit.Qubit], paulis: List[Pauli]) -> None: ...
    @overload
    def __init__(self, map: Dict[pytket._tket.circuit.Qubit,Pauli]) -> None: ...
    def commutes_with(self, other: QubitPauliString) -> bool: ...
    def compress(self) -> None: ...
    @overload
    def dot_state(self, state: npt.NDArray[numpy.complex128]) -> npt.NDArray[numpy.complex128]: ...
    @overload
    def dot_state(self, state: npt.NDArray[numpy.complex128], qubits: List[pytket._tket.circuit.Qubit]) -> npt.NDArray[numpy.complex128]: ...
    @classmethod
    def from_list(cls, arg0: json) -> QubitPauliString: ...
    @overload
    def state_expectation(self, state: npt.NDArray[numpy.complex128]) -> complex: ...
    @overload
    def state_expectation(self, state: npt.NDArray[numpy.complex128], qubits: List[pytket._tket.circuit.Qubit]) -> complex: ...
    def to_list(self) -> json: ...
    @overload
    def to_sparse_matrix(self) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, n_qubits: int) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    @overload
    def to_sparse_matrix(self, qubits: List[pytket._tket.circuit.Qubit]) -> scipy.sparse.csc_matrix[numpy.complex128]: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: pytket._tket.circuit.Qubit) -> Pauli: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: QubitPauliString) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __setitem__(self, arg0: pytket._tket.circuit.Qubit, arg1: Pauli) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    @property
    def map(self) -> Dict[pytket._tket.circuit.Qubit,Pauli]: ...

def pauli_string_mult(qubitpaulistring1: QubitPauliString, qubitpaulistring2: QubitPauliString) -> Tuple[QubitPauliString,complex]: ...
