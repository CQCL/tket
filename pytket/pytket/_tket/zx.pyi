from typing import Any
from typing import ClassVar, Dict, List, Optional, Tuple, Union

from typing import overload
import pytket._tket.circuit
import pytket._tket.unit_id
import sympy

class CliffordGen(ZXGen):
    def __init__(self, zxtype: ZXType, param: bool = ..., qtype: QuantumType = ...) -> None: ...
    @property
    def param(self) -> bool: ...

class DirectedGen(ZXGen):
    def __init__(self, zxtype: ZXType, qtype: QuantumType) -> None: ...
    @property
    def n_ports(self) -> int: ...
    @property
    def signature(self) -> List[QuantumType]: ...

class Flow:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def c(self, v: ZXVert) -> List[ZXVert]: ...
    def d(self, arg0: ZXVert) -> int: ...
    def focus(self, diag: ZXDiagram) -> None: ...
    @classmethod
    def identify_causal_flow(cls, diag: ZXDiagram) -> Flow: ...
    @classmethod
    def identify_focussed_sets(cls, diag: ZXDiagram) -> List[List[ZXVert]]: ...
    @classmethod
    def identify_pauli_flow(cls, diag: ZXDiagram) -> Flow: ...
    def odd(self, v: ZXVert, diag: ZXDiagram) -> List[ZXVert]: ...
    @property
    def cmap(self) -> Dict[ZXVert,List[ZXVert]]: ...
    @property
    def dmap(self) -> Dict[ZXVert,int]: ...

class PhasedGen(ZXGen):
    def __init__(self, zxtype: ZXType, param: Union[sympy.Expr,float] = ..., qtype: QuantumType = ...) -> None: ...
    @property
    def param(self) -> Union[sympy.Expr,float]: ...

class QuantumType:
    __members__: ClassVar[dict] = ...  # read-only
    Classical: ClassVar[QuantumType] = ...
    Quantum: ClassVar[QuantumType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Rewrite:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def apply(self, diag: ZXDiagram) -> bool: ...
    @classmethod
    def basic_wires(cls) -> Rewrite: ...
    @classmethod
    def decompose_boxes(cls) -> Rewrite: ...
    @classmethod
    def extend_at_boundary_paulis(cls) -> Rewrite: ...
    @classmethod
    def extend_for_PX_outputs(cls) -> Rewrite: ...
    @classmethod
    def gadgetise_interior_paulis(cls) -> Rewrite: ...
    @classmethod
    def internalise_gadgets(cls) -> Rewrite: ...
    @classmethod
    def io_extension(cls) -> Rewrite: ...
    @classmethod
    def merge_gadgets(cls) -> Rewrite: ...
    @classmethod
    def parallel_h_removal(cls) -> Rewrite: ...
    @classmethod
    def rebase_to_mbqc(cls) -> Rewrite: ...
    @classmethod
    def rebase_to_zx(cls) -> Rewrite: ...
    @classmethod
    def red_to_green(cls) -> Rewrite: ...
    @classmethod
    def reduce_graphlike_form(cls) -> Rewrite: ...
    @classmethod
    def remove_interior_cliffords(cls) -> Rewrite: ...
    @classmethod
    def remove_interior_paulis(cls) -> Rewrite: ...
    @classmethod
    def repeat(cls, rewrite: Rewrite) -> Rewrite: ...
    @classmethod
    def self_loop_removal(cls) -> Rewrite: ...
    @classmethod
    def separate_boundaries(cls) -> Rewrite: ...
    @classmethod
    def sequence(cls, sequence: List[Rewrite]) -> Rewrite: ...
    @classmethod
    def spider_fusion(cls) -> Rewrite: ...
    @classmethod
    def to_MBQC_diag(cls) -> Rewrite: ...
    @classmethod
    def to_graphlike_form(cls) -> Rewrite: ...

class ZXBox(ZXGen):
    def __init__(self, zxdiag: ZXDiagram) -> None: ...
    @property
    def diagram(self) -> ZXDiagram: ...
    @property
    def n_ports(self) -> int: ...
    @property
    def signature(self) -> List[QuantumType]: ...

class ZXDiagram:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, inputs: int, outputs: int, classical_inputs: int, classical_outputs: int) -> None: ...
    @overload
    def __init__(self, other: ZXDiagram) -> None: ...
    @overload
    def add_vertex(self, gen: ZXGen) -> ZXVert: ...
    @overload
    def add_vertex(self, type: ZXType, qtype: QuantumType = ...) -> ZXVert: ...
    @overload
    def add_vertex(self, type: ZXType, param: bool, qtype: QuantumType = ...) -> ZXVert: ...
    @overload
    def add_vertex(self, type: ZXType, param: Union[sympy.Expr,float], qtype: QuantumType = ...) -> ZXVert: ...
    def add_wire(self, u: ZXVert, v: ZXVert, type: ZXWireType = ..., qtype: QuantumType = ..., u_port: Optional[int] = ..., v_port: Optional[int] = ...) -> ZXWire: ...
    def add_zxbox(self, inner: ZXDiagram) -> ZXVert: ...
    def adj_wires(self, v: ZXVert) -> List[ZXWire]: ...
    def check_validity(self) -> None: ...
    def count_vertices(self, type: ZXType) -> int: ...
    def count_wires(self, type: ZXWireType) -> int: ...
    def degree(self, v: ZXVert) -> int: ...
    def free_symbols(self) -> set[sympy.Symbol]: ...
    def get_boundary(self, type: Optional[ZXType] = ..., qtype: Optional[QuantumType] = ...) -> List[ZXVert]: ...
    def get_name(self, v: ZXVert) -> str: ...
    def get_qtype(self, v: ZXVert) -> Optional[QuantumType]: ...
    def get_vertex_ZXGen(self, v: ZXVert) -> ZXGen: ...
    def get_wire_ends(self, w: ZXWire) -> Tuple[Tuple[ZXVert,Optional[int]],Tuple[ZXVert,Optional[int]]]: ...
    def get_wire_qtype(self, w: ZXWire) -> QuantumType: ...
    def get_wire_type(self, w: ZXWire) -> ZXWireType: ...
    def get_zxtype(self, v: ZXVert) -> ZXType: ...
    def is_symbolic(self) -> bool: ...
    def multiply_scalar(self, scalar: Union[sympy.Expr,float]) -> None: ...
    def neighbours(self, v: ZXVert) -> List[ZXVert]: ...
    def other_end(self, w: ZXWire, v: ZXVert) -> ZXVert: ...
    def remove_vertex(self, v: ZXVert) -> None: ...
    def remove_wire(self, w: ZXWire) -> None: ...
    def set_vertex_ZXGen(self, v: ZXVert, gen: ZXGen) -> None: ...
    def set_wire_qtype(self, w: ZXWire, qtype: QuantumType) -> None: ...
    def set_wire_type(self, w: ZXWire, type: ZXWireType) -> None: ...
    @overload
    def symbol_substitution(self, symbol_map: Dict[sympy.Symbol,Union[sympy.Expr,float]]) -> None: ...
    @overload
    def symbol_substitution(self, symbol_map: Dict[sympy.Symbol,float]) -> None: ...
    def to_circuit(self) -> Tuple[pytket._tket.circuit.Circuit,Dict[ZXVert,pytket._tket.unit_id.UnitID]]: ...
    def to_doubled_diagram(self) -> ZXDiagram: ...
    def to_graphviz_str(self) -> str: ...
    def wire_at_port(self, v: ZXVert, port: int) -> ZXWire: ...
    def wire_between(self, u: ZXVert, v: ZXVert) -> Optional[ZXWire]: ...
    def wires_between(self, u: ZXVert, v: ZXVert) -> List[ZXWire]: ...
    @property
    def n_vertices(self) -> int: ...
    @property
    def n_wires(self) -> int: ...
    @property
    def scalar(self) -> Union[sympy.Expr,float]: ...
    @property
    def vertices(self) -> List[ZXVert]: ...
    @property
    def wires(self) -> List[ZXWire]: ...

class ZXGen:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    @classmethod
    def create(cls, type: ZXType, qtype: QuantumType = ...) -> ZXGen: ...
    @overload
    @classmethod
    def create(cls, type: ZXType, param: Union[sympy.Expr,float], qtype: QuantumType = ...) -> ZXGen: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def qtype(self) -> Optional[QuantumType]: ...
    @property
    def type(self) -> ZXType: ...

class ZXType:
    __members__: ClassVar[dict] = ...  # read-only
    Hbox: ClassVar[ZXType] = ...
    Input: ClassVar[ZXType] = ...
    Open: ClassVar[ZXType] = ...
    Output: ClassVar[ZXType] = ...
    PX: ClassVar[ZXType] = ...
    PY: ClassVar[ZXType] = ...
    PZ: ClassVar[ZXType] = ...
    Triangle: ClassVar[ZXType] = ...
    XSpider: ClassVar[ZXType] = ...
    XY: ClassVar[ZXType] = ...
    XZ: ClassVar[ZXType] = ...
    YZ: ClassVar[ZXType] = ...
    ZSpider: ClassVar[ZXType] = ...
    ZXBox: ClassVar[ZXType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ZXVert:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...

class ZXWire:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...

class ZXWireType:
    __members__: ClassVar[dict] = ...  # read-only
    Basic: ClassVar[ZXWireType] = ...
    H: ClassVar[ZXWireType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def circuit_to_zx(arg0: pytket._tket.circuit.Circuit) -> Tuple[ZXDiagram,Dict[pytket._tket.unit_id.UnitID,Tuple[ZXVert,ZXVert]]]: ...
