#!/usr/bin/python3
import os
import re
import subprocess
from pathlib import Path
import argparse


def replace_in_file_string(file_string: str, matcher: str, replacement: str) -> tuple[str, int]:
    split_text = re.split(matcher, file_string)
    modified_text = replacement.join(split_text)
    return modified_text, len(split_text) - 1


def replace_in_file_string_multiline(file_string: str, matcher: str, replacement: str) -> tuple[str, int]:
    split_text = re.split(matcher, file_string, re.MULTILINE)
    modified_text = replacement.join(split_text)
    return modified_text, len(split_text) - 1


def handle_args_kwargs_types(file_string: str) -> tuple[str, int]:
    modified, n_args = replace_in_file_string(file_string, "\*args", "*args: Any")
    modified, n_kwargs = replace_in_file_string(modified, "\*\*kwargs", "**kwargs: Any")
    n_total = n_args + n_kwargs
    if n_total > 0 and not re.search("from typing import .*Any", modified):
        modified = "from typing import Any" + os.linesep + modified
    return modified, n_total > 0


def handle_numpy_stuff(file_string: str) -> tuple[str, bool]:
    split_text = re.split("numpy\.ndarray\[", file_string)
    modified_text = "NDArray[".join(split_text)
    if len(split_text) > 1:
        modified_text, _ = replace_in_file_string(modified_text, "\[.,.\]", "")
        modified_text, _ = replace_in_file_string(modified_text, "NDArray\[bool\]", "NDArray[numpy.bool_]")
        modified_text = "from numpy.typing import NDArray" + os.linesep + modified_text
        return modified_text, True
    return file_string, False


def handle_circuit_depth_problem(file_string: str) -> str:
    split_text = re.split(f'@overload{os.linesep}\s+def depth\(self\) -> int: \.\.\.', file_string, re.MULTILINE)
    modified = "def depth(self) -> int: ...".join(split_text)
    split_text = re.split(f'@overload{os.linesep}\s+def depth\(self\) -> Any: \.\.\.{os.linesep}\s+', modified, re.MULTILINE)
    modified = "".join(split_text)
    split_text = re.split(f'@overload{os.linesep}\s+def depth_2q\(self\) -> int: \.\.\.', modified, re.MULTILINE)
    modified = "def depth_2q(self) -> int: ...".join(split_text)
    split_text = re.split(f'@overload{os.linesep}\s+def depth_2q\(self\) -> Any: \.\.\.{os.linesep}\s+', modified, re.MULTILINE)
    modified = "".join(split_text)
    return modified


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog='StubGenerator',
        description='generates type stubs for pybind11 modules',
    )

    pytket_dir = Path(__file__).parent.parent.resolve()
    gen_root_dir = pytket_dir

    subprocess.run(["stubgen", "-p", "pytket._tket", "-o", gen_root_dir])
    print("Cleanup:")
    for path in Path(f'{gen_root_dir}/pytket/_tket').iterdir():
        if path.is_file() and path.suffix == ".pyi":
            print(path)
            with path.open('r+') as file:
                text = file.read()
                text, was_modified = handle_args_kwargs_types(text)
                print(f"   required args, kwargs fixes: {was_modified}")
                text, n = replace_in_file_string(text, "Set\[", "set[")
                print(f"   required Set[ -> set[: {n>0}")
                text, was_modified = handle_numpy_stuff(text)
                print(f"   required numpy fixes: {was_modified}")

                # file specific stuff
                if path.name == "circuit.pyi":
                    print("special stuff for circuit.pyi")
                    text = handle_circuit_depth_problem(text)

            with path.open('w') as file:
                file.write(text)

